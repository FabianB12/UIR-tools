<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UIR Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #f3f4f6;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        /* Navigation */
        nav {
            background-color: #1f2937;
            color: white;
            padding: 0 20px;
            height: 50px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .nav-item {
            padding: 0 20px;
            height: 100%;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            font-weight: 500;
            color: #9ca3af;
        }
        .nav-item:hover { color: white; background-color: #374151; }
        .nav-item.active {
            color: white;
            border-bottom-color: #3b82f6;
            background-color: #111827;
        }

        /* Layout */
        .main-container {
            flex-grow: 1;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            gap: 20px;
            overflow-y: auto;
            position: relative;
        }
        
        /* Views */
        .view-section { display: none; width: 100%; height: 100%; flex-direction: row; justify-content: center; gap: 20px;}
        .view-section.active { display: flex; }

        /* Canvas */
        .canvas-wrapper {
            position: relative;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
            background: white;
        }
        canvas { display: block; cursor: crosshair; }

        /* Sidebar */
        .sidebar {
            width: 360px;
            background: white;
            padding: 0;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
            max-height: 600px; /* Constrain height */
        }
        .sidebar-scroll {
            overflow-y: auto;
            flex-grow: 1;
        }
        .tab-header { display: flex; border-bottom: 1px solid #e5e7eb; background: #f9fafb; }
        .tab-btn {
            flex: 1;
            padding: 12px;
            text-align: center;
            font-weight: 600;
            color: #6b7280;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .tab-btn:hover { background: #f3f4f6; }
        .tab-btn.active { background: white; color: #2563eb; border-bottom: 2px solid #2563eb; }

        /* Content Blocks */
        .sidebar-content { padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        .step-item {
            padding: 8px 12px;
            border-left: 4px solid #e5e7eb;
            background-color: #f9fafb;
            color: #6b7280;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }
        .step-item.active {
            border-left-color: #2563eb;
            background-color: #eff6ff;
            color: #1e40af;
            font-weight: 600;
        }
        
        /* Educational Text */
        .edu-card {
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }
        .edu-title { font-weight: bold; color: #1f2937; font-size: 0.95rem; margin-bottom: 4px; }
        .edu-text { font-size: 0.85rem; color: #4b5563; line-height: 1.4; }

        /* RRT* Styles */
        .rrt-star-only { display: none; border-left-color: #9333ea; }
        .rrt-star-active .rrt-star-only { display: flex; }
        .algo-section { display: none; }
        .algo-section.active { display: block; }
        
        /* Grid Steps */
        .grid-theta-only { display: none; border-left-color: #059669; }
        .grid-theta-active .grid-theta-only { display: flex; }
        
        .grid-dlite-section { display: none; }
        .grid-dlite-active .grid-astar-section { display: none; }
        .grid-dlite-active .grid-dlite-section { display: block; }

        /* Controls Area at bottom of screen (Global) */
        .controls-bar {
            background: white;
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: center;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            z-index: 20;
        }
        
        /* Inputs */
        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }
        input[type=range] { height: 6px; border-radius: 5px; outline: none; accent-color: #2563eb; }

        /* Left Explanation Sidebar */
        .left-sidebar {
            width: 320px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
            max-height: 600px;
        }
        .left-sidebar-header {
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            color: white;
            padding: 16px 20px;
            font-weight: 700;
            font-size: 1.1rem;
        }
        .left-sidebar-content {
            overflow-y: auto;
            padding: 16px;
            flex-grow: 1;
        }
        .algo-explain {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e5e7eb;
        }
        .algo-explain:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .algo-explain-title {
            font-weight: 700;
            color: #1e40af;
            font-size: 0.95rem;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .algo-explain-title .badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        .algo-explain-text {
            font-size: 0.82rem;
            color: #374151;
            line-height: 1.5;
        }
        .algo-explain-text strong {
            color: #1f2937;
        }
        .algo-explain-text ul {
            margin-top: 6px;
            padding-left: 16px;
        }
        .algo-explain-text li {
            margin-bottom: 3px;
        }
        .algo-explain-text code {
            background: #f3f4f6;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 0.78rem;
            color: #dc2626;
        }
        .algo-intro {
            background: #f0f9ff;
            border-left: 4px solid #3b82f6;
            padding: 12px;
            margin-bottom: 16px;
            border-radius: 0 6px 6px 0;
        }
        .algo-intro p {
            font-size: 0.85rem;
            color: #1e40af;
            line-height: 1.5;
        }
        .sketch-hint {
            background: #fef3c7;
            border: 1px dashed #f59e0b;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #92400e;
            margin-top: 8px;
        }
    </style>
</head>
<body>

    <!-- Header -->
    <nav>
        <div class="font-bold text-lg mr-8 tracking-tight">UIR Guide</div>
        <div class="nav-item active" onclick="switchMainView('SAMPLING')" id="nav-SAMPLING">Sampling</div>
        <div class="nav-item" onclick="switchMainView('TSP')" id="nav-TSP">Multi-Goal</div>
        <div class="nav-item" onclick="switchMainView('GRID')" id="nav-GRID">Grid Search</div>
        <div class="nav-item" onclick="switchMainView('EXPLORE')" id="nav-EXPLORE">Exploration</div>
    </nav>

    <div class="main-container">
        
        <!-- ==================== VIEW 1: RRT / PRM ==================== -->
        <div id="view-SAMPLING" class="view-section active">
            <!-- Left Explanation Sidebar -->
            <div class="left-sidebar">
                <div class="left-sidebar-header">Sampling-Based Planning</div>
                <div class="left-sidebar-content">
                    <div class="algo-intro">
                        <p><strong>What is it?</strong> Methods that explore C-space by randomly sampling configurations and connecting them, avoiding explicit construction of C-space obstacles.</p>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            RRT <span class="badge bg-blue-100 text-blue-700">Rapidly-exploring Random Tree</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Idea:</strong> Grow a tree from start toward random samples, biased toward unexplored regions.
                            <ul>
                                <li><strong>Sample</strong> random point q<sub>rand</sub></li>
                                <li><strong>Find nearest</strong> node q<sub>near</sub> in tree</li>
                                <li><strong>Steer</strong> from q<sub>near</sub> toward q<sub>rand</sub> by step size ε</li>
                                <li><strong>If collision-free</strong>, add new node to tree</li>
                            </ul>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Draw tree branching out from start, with random samples pulling it toward unexplored space.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            RRT* <span class="badge bg-purple-100 text-purple-700">Optimal RRT</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Key difference:</strong> Asymptotically optimal - finds shortest path as samples → ∞.
                            <ul>
                                <li><strong>Find neighbors</strong> within radius r (not just nearest)</li>
                                <li><strong>Choose best parent</strong> - connect to neighbor giving lowest cost-to-come</li>
                                <li><strong>Rewire</strong> - check if new node is better parent for neighbors</li>
                            </ul>
                            <strong>Radius:</strong> <code>r = γ·(log(n)/n)^(1/d)</code>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Show rewiring - dashed line to old parent, solid to new better parent.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            RRG <span class="badge bg-green-100 text-green-700">Rapidly-exploring Random Graph</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Idea:</strong> Like RRT* but creates a <strong>graph</strong> instead of tree.
                            <ul>
                                <li>Connect new node to <strong>ALL</strong> collision-free neighbors in radius</li>
                                <li>Multiple paths to each node (redundancy)</li>
                                <li>Useful when you need alternative routes</li>
                            </ul>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Show node with multiple edges to neighbors, not just one parent.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            PRM <span class="badge bg-orange-100 text-orange-700">Probabilistic Roadmap</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Idea:</strong> Two-phase approach for <strong>multi-query</strong> planning.
                            <ul>
                                <li><strong>Learning phase:</strong> Sample N random configs, connect neighbors within radius r if collision-free → build roadmap graph</li>
                                <li><strong>Query phase:</strong> Connect start/goal to roadmap, run Dijkstra/A*</li>
                            </ul>
                            <strong>When to use:</strong> Same environment, many different start/goal pairs.
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Scattered nodes connected by edges forming a network. Start/goal connect to nearby nodes.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">Comparison</div>
                        <div class="algo-explain-text">
                            <table style="width:100%; font-size:0.75rem; border-collapse:collapse;">
                                <tr style="background:#f3f4f6;"><th style="text-align:left;padding:4px;">Method</th><th style="padding:4px;">Optimal?</th><th style="padding:4px;">Multi-query?</th></tr>
                                <tr><td style="padding:4px;">RRT</td><td style="text-align:center;">No</td><td style="text-align:center;">No</td></tr>
                                <tr style="background:#f9fafb;"><td style="padding:4px;">RRT*</td><td style="text-align:center;">Yes (asymp.)</td><td style="text-align:center;">No</td></tr>
                                <tr><td style="padding:4px;">RRG</td><td style="text-align:center;">Yes (asymp.)</td><td style="text-align:center;">Partial</td></tr>
                                <tr style="background:#f9fafb;"><td style="padding:4px;">PRM</td><td style="text-align:center;">Roadmap-optimal</td><td style="text-align:center;">Yes</td></tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="rrtCanvas" width="500" height="500"></canvas>
            </div>

            <div class="sidebar">
                <div class="tab-header">
                    <div class="tab-btn active" onclick="switchRrtTab('RRT')" id="tab-RRT">RRT Family</div>
                    <div class="tab-btn" onclick="switchRrtTab('PRM')" id="tab-PRM">PRM</div>
                    <div class="tab-btn" onclick="switchRrtTab('EDU')" id="tab-RRT-EDU">Topic Guide</div>
                </div>
                <div class="sidebar-scroll">
                    <div class="sidebar-content">
                        <!-- RRT Steps -->
                        <div id="section-RRT" class="algo-section active">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-xl font-bold text-gray-800">RRT Steps</h2>
                                <div class="text-xs font-bold px-2 py-1 rounded bg-gray-200" id="rrt-mode-badge">RRT</div>
                            </div>
                            <div class="flex flex-col" id="rrt-steps-container">
                                <div id="step-rrt-1" class="step-item">1. Sample Random Point</div>
                                <div id="step-rrt-2" class="step-item">2. Find Nearest Node</div>
                                <div id="step-rrt-3" class="step-item">3. Steer / Extend</div>
                                <div id="step-rrt-4" class="step-item">4. Check Collision</div>
                                <div id="step-rrt-8" class="step-item rrt-star-only">5a. Find Neighbors (RRT*)</div>
                                <div id="step-rrt-5" class="step-item"><span>5b. Add to Tree</span></div>
                                <div id="step-rrt-9" class="step-item rrt-star-only">6. Rewire Neighbors (RRT*)</div>
                                <div id="step-rrt-6" class="step-item hidden">7. Success!</div>
                            </div>

                        </div>

                        <!-- PRM Steps -->
                        <div id="section-PRM" class="algo-section">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-xl font-bold text-gray-800">PRM Steps</h2>
                                <div class="text-xs font-bold px-2 py-1 rounded bg-indigo-100 text-indigo-800">Multi-Query</div>
                            </div>
                            <div class="flex flex-col">
                                <div id="step-prm-1" class="step-item">1. Sample N Nodes</div>
                                <div id="step-prm-2" class="step-item">2. Connect Neighbors (k-NN)</div>
                                <div id="step-prm-3" class="step-item">3. Connect Start & Goal</div>
                                <div id="step-prm-4" class="step-item">4. Graph Search (A*)</div>
                                <div id="step-prm-5" class="step-item hidden">5. Path Found!</div>
                            </div>

                            <!-- PRM Key Concept -->
                            <div class="mt-4 p-3 bg-indigo-50 border border-indigo-100 rounded text-xs">
                                <p class="font-bold text-indigo-700 mb-1">Multi-Query Advantage:</p>
                                <p class="text-indigo-900">Once roadmap is built, it can be reused for multiple start/goal queries without rebuilding!</p>
                            </div>
                        </div>

                        <!-- Educational Content -->
                        <div id="section-RRT-EDU" class="algo-section">
                            <h2 class="text-xl font-bold text-gray-800 mb-4">Exam Questions & Answers</h2>

                            <div class="edu-card">
                                <div class="edu-title">1. What is the main idea of sampling-based motion planning?</div>
                                <div class="edu-text">
                                    Instead of explicitly computing C<sub>free</sub>, we <strong>sample random configurations</strong> and check collision.
                                    Build a graph/tree in C-space incrementally. Avoids curse of dimensionality.
                                    <br><em>"Náhodné vzorkování konfiguračního prostoru místo explicitního výpočtu."</em>
                                </div>
                            </div>

                            <div class="edu-card">
                                <div class="edu-title">2. Multi-query vs Single-query algorithms?</div>
                                <div class="edu-text">
                                    <strong>Multi-query (PRM):</strong> Preprocessing phase builds roadmap. Reusable for multiple queries.<br>
                                    <strong>Single-query (RRT):</strong> Builds tree from scratch for each query. Better when environment changes.
                                    <br><em>"PRM = předzpracování, RRT = od nuly pro každý dotaz."</em>
                                </div>
                            </div>

                            <div class="edu-card">
                                <div class="edu-title">3. What is Probabilistic Completeness?</div>
                                <div class="edu-text">
                                    If a solution exists, the probability of finding it approaches 1 as the number of samples → ∞.
                                    <br><code>P(find path | path exists) → 1 as n → ∞</code>
                                    <br><em>"Pravděpodobnost nalezení cesty jde k 1."</em>
                                </div>
                            </div>

                            <div class="edu-card">
                                <div class="edu-title">4. What is Asymptotic Optimality?</div>
                                <div class="edu-text">
                                    The cost of the solution converges to the optimal cost as samples → ∞.
                                    <br><strong>RRT:</strong> NOT asymptotically optimal (gets stuck in local minima).
                                    <br><strong>RRT*, PRM*:</strong> ARE asymptotically optimal.
                                    <br><em>"RRT* konverguje k optimu, RRT ne."</em>
                                </div>
                            </div>

                            <div class="edu-card">
                                <div class="edu-title">5. Describe RRT algorithm steps.</div>
                                <div class="edu-text">
                                    <ol class="list-decimal pl-4">
                                        <li>Sample random configuration q<sub>rand</sub></li>
                                        <li>Find nearest node q<sub>near</sub> in tree</li>
                                        <li>Steer: extend towards q<sub>rand</sub> by step Δq</li>
                                        <li>If collision-free, add new node to tree</li>
                                        <li>Repeat until goal reached</li>
                                    </ol>
                                </div>
                            </div>

                            <div class="edu-card">
                                <div class="edu-title">6. How does RRT* differ from RRT?</div>
                                <div class="edu-text">
                                    Two key additions:
                                    <ul class="list-disc pl-4">
                                        <li><strong>Best parent selection:</strong> Check all neighbors within radius r, choose one giving lowest cost.</li>
                                        <li><strong>Rewiring:</strong> After adding node, check if routing through it reduces cost for neighbors.</li>
                                    </ul>
                                    <em>"Výběr nejlepšího rodiče + přepojení sousedů."</em>
                                </div>
                            </div>

                            <div class="edu-card">
                                <div class="edu-title">7. What is RRG (Rapidly-exploring Random Graph)?</div>
                                <div class="edu-text">
                                    Like RRT but maintains a <strong>graph</strong> instead of tree.
                                    New nodes connect to ALL neighbors within radius (not just best parent).
                                    More edges = more path options, but higher memory.
                                    <br><em>"Graf místo stromu - více hran, více cest."</em>
                                </div>
                            </div>

                            <div class="edu-card">
                                <div class="edu-title">8. What are Informed RRT* and RABIT*?</div>
                                <div class="edu-text">
                                    <strong>Informed RRT*:</strong> After finding initial path, samples only within ellipsoidal heuristic region that could improve cost.<br>
                                    <strong>RABIT*:</strong> Regionally Accelerated BIT* - combines batch sampling with heuristic guidance.
                                    <br><em>"Informované vzorkování v elipse možného zlepšení."</em>
                                </div>
                            </div>
                        </div>

                        <!-- Stats -->
                        <div class="mt-4 p-3 bg-gray-100 rounded text-sm text-gray-700">
                            <p><strong>Nodes:</strong> <span id="node-count">0</span></p>
                            <p><strong>Path Cost:</strong> <span id="cost-count">-</span></p>
                            <p class="mt-2 text-xs text-gray-500" id="status-text">Ready</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== VIEW 2: TSP / TSPN ==================== -->
        <div id="view-TSP" class="view-section">
            <!-- Left Explanation Sidebar -->
            <div class="left-sidebar">
                <div class="left-sidebar-header">Multi-Goal & TSP Planning</div>
                <div class="left-sidebar-content">
                    <div class="algo-intro">
                        <p><strong>What is it?</strong> Planning problems involving visiting multiple goal locations, optimizing order and/or paths. Related to the classic Traveling Salesman Problem.</p>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            TSP <span class="badge bg-blue-100 text-blue-700">Traveling Salesman Problem</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Problem:</strong> Visit ALL n cities exactly once and return to start, minimizing total distance.
                            <ul>
                                <li><strong>Input:</strong> Set of n points (cities)</li>
                                <li><strong>Output:</strong> Optimal tour (permutation)</li>
                                <li><strong>Complexity:</strong> NP-hard, O(n!) brute force</li>
                            </ul>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Points connected in a loop, forming closed tour through all cities.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            TSPN <span class="badge bg-purple-100 text-purple-700">TSP with Neighborhoods</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Key difference:</strong> Don't visit exact points - visit <strong>regions</strong> (neighborhoods).
                            <ul>
                                <li>Each goal is a disk/polygon region</li>
                                <li>Robot must enter each region (anywhere inside)</li>
                                <li>Optimizes both <strong>order</strong> and <strong>entry points</strong></li>
                            </ul>
                            <strong>Why useful?</strong> Sensor coverage, inspection tasks where exact position doesn't matter.
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Circles (regions) connected by path that touches edge of each circle, not center.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            Dubins Vehicle <span class="badge bg-green-100 text-green-700">Curvature-Constrained</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>What is it?</strong> Vehicle that can only move <strong>forward</strong> with <strong>bounded turning radius</strong> ρ<sub>min</sub>.
                            <ul>
                                <li><strong>Config:</strong> (x, y, θ) - position + heading</li>
                                <li><strong>Dubins curves:</strong> Shortest path is always CSC or CCC (C=arc, S=straight)</li>
                                <li><strong>6 types:</strong> LSL, RSR, LSR, RSL, RLR, LRL</li>
                            </ul>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Show car with turning circles. Path = arc + line + arc.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            SOM Solver <span class="badge bg-orange-100 text-orange-700">Self-Organizing Map</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Idea:</strong> Neural network approach to approximate TSP solution.
                            <ul>
                                <li>Ring of neurons representing tour</li>
                                <li><strong>Learning:</strong> Present random city, pull nearest neuron and neighbors toward it</li>
                                <li>Ring gradually wraps around all cities</li>
                                <li>Fast approximation, not guaranteed optimal</li>
                            </ul>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Elastic ring deforming to pass through scattered points.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">Key Formulas</div>
                        <div class="algo-explain-text">
                            <strong>Euclidean TSP:</strong> dist = √[(x₂-x₁)² + (y₂-y₁)²]<br>
                            <strong>Dubins length:</strong> L = ρ·(|α| + |β|) + d (for CSC)<br>
                            <strong>SOM update:</strong> w<sub>i</sub> += η·h(i,winner)·(city - w<sub>i</sub>)
                        </div>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="tspCanvas" width="500" height="500"></canvas>
            </div>

            <div class="sidebar">
                <div class="tab-header">
                    <div class="tab-btn active" onclick="switchTspTab('CTRL')" id="tab-TSP-CTRL">Controls</div>
                    <div class="tab-btn" onclick="switchTspTab('DUBINS')" id="tab-TSP-DUBINS">Dubins Demo</div>
                    <div class="tab-btn" onclick="switchTspTab('EDU')" id="tab-TSP-EDU">Guide</div>
                </div>
                
                <div class="sidebar-scroll">
                    <!-- TSP Controls -->
                    <div id="section-TSP-CTRL" class="sidebar-content algo-section active">
                        <h2 class="text-xl font-bold text-gray-800 mb-2">Multi-Goal Solver</h2>
                        <p class="text-xs text-gray-500 mb-4">Algorithm: Self-Organizing Map (SOM)</p>

                        <!-- Toggles -->
                        <div class="space-y-3">
                            <div class="flex items-center justify-between bg-gray-50 p-2 rounded">
                                <span class="text-sm font-semibold text-gray-700">Problem Type</span>
                                <div class="flex bg-gray-200 rounded p-1">
                                    <button onclick="setTspMode('TSP')" id="btn-mode-tsp" class="px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600">TSP</button>
                                    <button onclick="setTspMode('TSPN')" id="btn-mode-tspn" class="px-3 py-1 text-xs rounded text-gray-600">TSPN</button>
                                </div>
                            </div>
                            
                            <div class="flex items-center justify-between bg-gray-50 p-2 rounded">
                                <span class="text-sm font-semibold text-gray-700">Vehicle Model</span>
                                <div class="flex bg-gray-200 rounded p-1">
                                    <button onclick="setDubins(false)" id="btn-dubins-off" class="px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600">Euclidean</button>
                                    <button onclick="setDubins(true)" id="btn-dubins-on" class="px-3 py-1 text-xs rounded text-gray-600">Dubins</button>
                                </div>
                            </div>
                        </div>

                        <div class="mt-4 p-3 bg-indigo-50 border border-indigo-100 rounded text-sm text-indigo-900">
                            <p class="font-bold text-xs uppercase text-indigo-500 mb-1">Status</p>
                            <p><strong>Tour Length:</strong> <span id="tsp-cost">0</span></p>
                            <p><strong>Neurons:</strong> <span id="som-neurons">0</span></p>
                            <p id="tsp-status" class="mt-2 text-xs italic">Add targets by clicking the map.</p>
                        </div>
                    </div>

                    <!-- Dubins Demo Section -->
                    <div id="section-TSP-DUBINS" class="sidebar-content algo-section">
                        <h2 class="text-xl font-bold text-gray-800 mb-2">Dubins Path Demo</h2>
                        <p class="text-xs text-gray-500 mb-4">Interactive visualization of Dubins curves</p>

                        <!-- Turning Radius -->
                        <div class="flex items-center justify-between bg-gray-50 p-2 rounded mb-3">
                            <span class="text-sm font-semibold text-gray-700">Turning Radius</span>
                            <div class="flex items-center gap-2">
                                <input type="range" min="30" max="100" value="50" id="dubins-radius-slider" class="w-20" oninput="updateDubinsRadius(this.value)">
                                <span class="text-xs font-mono w-8" id="dubins-radius-val">50</span>
                            </div>
                        </div>

                        <!-- Instructions -->
                        <div class="p-3 bg-blue-50 border border-blue-100 rounded text-xs mb-3">
                            <p class="font-bold text-blue-700 mb-1">How to use:</p>
                            <p><strong>Left click:</strong> Set START position & heading</p>
                            <p><strong>Right click:</strong> Set GOAL position & heading</p>
                            <p><strong>Drag:</strong> Adjust heading direction</p>
                        </div>

                        <!-- Path Type Display -->
                        <div class="p-3 bg-purple-50 border border-purple-100 rounded mb-3">
                            <p class="font-bold text-purple-700 text-sm mb-2">Current Path: <span id="dubins-path-type" class="font-mono">RSR</span></p>
                            <p class="text-xs text-purple-900"><strong>Length:</strong> <span id="dubins-path-length">0</span> units</p>
                        </div>

                        <!-- Visual Legend -->
                        <div class="p-3 bg-gray-50 rounded text-xs mb-3">
                            <p class="font-bold mb-2">Legend:</p>
                            <div class="space-y-1">
                                <div class="flex items-center gap-2"><span class="w-3 h-3 rounded-full bg-green-500"></span> Start config (S)</div>
                                <div class="flex items-center gap-2"><span class="w-3 h-3 rounded-full bg-red-500"></span> Goal config (G)</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-0.5 bg-green-300"></span> Left turning circle</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-0.5 bg-blue-300"></span> Right turning circle</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-1 bg-orange-500"></span> Arc segment</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-1 bg-purple-500"></span> Straight segment</div>
                            </div>
                        </div>

                        <!-- Reset Button -->
                        <button onclick="resetDubinsDemo()" class="w-full py-2 px-4 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded text-sm font-semibold mb-3">
                            Reset Demo
                        </button>

                        <!-- Explanation -->
                        <div class="p-3 bg-amber-50 border border-amber-100 rounded text-xs">
                            <p class="font-bold text-amber-700 mb-1">What you're seeing:</p>
                            <p class="text-amber-900">
                                Each configuration has <strong>2 turning circles</strong> (left & right).
                                The Dubins path uses <strong>arcs on these circles</strong> connected by a <strong>straight tangent line</strong>.
                            </p>
                            <p class="text-amber-900 mt-2">
                                <strong>CSC</strong> = arc + straight + arc<br>
                                <strong>CCC</strong> = arc + arc + arc (no straight)
                            </p>
                        </div>
                    </div>

                    <!-- TSP Education / Questions -->
                    <div id="section-TSP-EDU" class="sidebar-content algo-section">
                        <h2 class="text-xl font-bold text-gray-800 mb-4">Exam Questions & Answers</h2>

                        <div class="edu-card">
                            <div class="edu-title">1. Main differences between TSP and TSPN?</div>
                            <div class="edu-text">
                                <strong>TSP:</strong> Visits specific points. Optimization of order only.<br>
                                <strong>TSPN:</strong> Visits regions (neighborhoods). Optimization of order AND specific location within region.<br>
                                <em>"TSP navštěvuje body, TSPN navštěvuje regiony/okolí."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">2. Describe the Dubins vehicle model.</div>
                            <div class="edu-text">
                                A kinematic model with:
                                <ul class="list-disc pl-4 mt-1">
                                    <li>Constant forward speed v</li>
                                    <li>Limited turning radius ρ (cannot turn on spot)</li>
                                    <li>State: (x, y, θ) - position and heading</li>
                                </ul>
                                <code>ẋ = v·cos(θ), ẏ = v·sin(θ), θ̇ = u/ρ</code><br>
                                <em>"Konstantní rychlost, omezený poloměr otáčení."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">3. What is the optimal Dubins path?</div>
                            <div class="edu-text">
                                Shortest path between two states (x,y,θ) consists of at most 3 segments:<br>
                                <strong>CSC:</strong> Curve-Straight-Curve (e.g., LSL, RSR, LSR, RSL)<br>
                                <strong>CCC:</strong> Curve-Curve-Curve (e.g., LRL, RLR)<br>
                                L=Left turn, R=Right turn, S=Straight<br>
                                <em>"Maximálně 3 segmenty: oblouky a přímky."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">4. Ordinary TSP vs Dubins TSP?</div>
                            <div class="edu-text">
                                <strong>Ordinary TSP:</strong> Euclidean distance (straight lines). Heading irrelevant. Symmetric distances.<br>
                                <strong>Dubins TSP:</strong> Distance depends on position AND heading (θ). Paths are curves. <strong>Asymmetric!</strong> d(A→B) ≠ d(B→A)<br>
                                <em>"DTSP závisí na poloze i směru, asymetrické vzdálenosti."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">5. Formal Multi-Goal Planning Problem?</div>
                            <div class="edu-text">
                                Find trajectory σ(t) on [0, T] such that for every goal region R<sub>i</sub>, ∃t<sub>i</sub> where σ(t<sub>i</sub>) ∈ R<sub>i</sub>.<br>
                                <strong>Admissible solution:</strong> Visits all goals, respects robot constraints.<br>
                                <strong>Objective:</strong> Minimize total path length or time T.<br>
                                <em>"Trajektorie navštíví všechny regiony."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">6. SOM for TSP/TSPN?</div>
                            <div class="edu-text">
                                Self-Organizing Map: ring of neurons adapts to targets.
                                <ul class="list-disc pl-4 mt-1">
                                    <li><strong>Winner:</strong> Neuron closest to selected target</li>
                                    <li><strong>Update:</strong> Winner + neighbors move toward target</li>
                                    <li><strong>TSPN mod:</strong> Attract to closest point in region, not center</li>
                                </ul>
                                <em>"Vítězný neuron táhne sousedy k cíli."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">7. Define Generalized TSP (GTSP)?</div>
                            <div class="edu-text">
                                Given clusters of cities, visit <strong>exactly one city from each cluster</strong>.<br>
                                <strong>Noon-Bean transformation:</strong> Convert GTSP to Asymmetric TSP by adding zero-cost edges within clusters.<br>
                                <em>"Navštiv právě jeden bod z každého clusteru."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">8. TSP Approximation Algorithms?</div>
                            <div class="edu-text">
                                <strong>Nearest Neighbor:</strong> Greedy, O(n²), factor ≈ log(n)<br>
                                <strong>Christofides:</strong> MST + matching + Eulerian, 3/2-approximation for metric TSP<br>
                                <strong>2-opt, 3-opt:</strong> Local search improvements<br>
                                <em>"Christofides garantuje 1.5× optimum."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">9. Orienteering Problem (OP)?</div>
                            <div class="edu-text">
                                <strong>TSP:</strong> Visit ALL goals, minimize cost<br>
                                <strong>OP:</strong> Budget constraint B, maximize collected prizes<br>
                                Goals have prizes p<sub>i</sub>. Find route with total length ≤ B maximizing Σp<sub>i</sub>.<br>
                                <em>"Rozpočet na cestu, maximalizuj zisk."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">10. Dubins Touring Problem (DTP)?</div>
                            <div class="edu-text">
                                Visit sequence of goals with Dubins vehicle. Order is fixed, optimize entry headings.<br>
                                <strong>Solution:</strong> Discretize headings at each goal, build graph, find shortest path.<br>
                                <strong>Lower bound:</strong> Sum of minimum Dubins distances between consecutive goals.<br>
                                <em>"Pořadí dané, optimalizuj směry příjezdu."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">11. DTSPN - Dubins TSP with Neighborhoods?</div>
                            <div class="edu-text">
                                Combine Dubins vehicle constraints with region visits.<br>
                                <strong>Approaches:</strong>
                                <ul class="list-disc pl-4 mt-1">
                                    <li>Decoupled: Solve TSPN first, then optimize Dubins paths</li>
                                    <li>Sampling: Sample boundary points, solve as DTSP</li>
                                    <li>SOM-based: Adapted neural network approach</li>
                                </ul>
                                <em>"Dubins vozidlo + návštěva regionů."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">12. Decoupled vs Coupled approaches?</div>
                            <div class="edu-text">
                                <strong>Decoupled:</strong> Solve subproblems separately (e.g., TSP order first, then path planning). Faster but suboptimal.<br>
                                <strong>Coupled:</strong> Solve jointly considering all constraints. Better solutions but harder.<br>
                                <em>"Decoupled = rychlejší, Coupled = lepší řešení."</em>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== VIEW 3: GRID / A* / THETA* ==================== -->
        <div id="view-GRID" class="view-section">
            <!-- Left Explanation Sidebar -->
            <div class="left-sidebar">
                <div class="left-sidebar-header">Grid-Based Planning</div>
                <div class="left-sidebar-content">
                    <div class="algo-intro">
                        <p><strong>What is it?</strong> Discretize continuous space into a grid (occupancy map). Each cell is free or occupied. Plan by searching the grid graph.</p>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            A* <span class="badge bg-blue-100 text-blue-700">Optimal Graph Search</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Core formula:</strong> <code>f(n) = g(n) + h(n)</code>
                            <ul>
                                <li><strong>g(n):</strong> Actual cost from start to n</li>
                                <li><strong>h(n):</strong> Heuristic (estimated cost to goal)</li>
                                <li><strong>f(n):</strong> Total estimated cost through n</li>
                            </ul>
                            <strong>Always expand node with lowest f(n).</strong><br>
                            <strong>Optimal if:</strong> h(n) is admissible (never overestimates).
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Grid with open set (frontier) and closed set (visited). Arrows showing expansion.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            Theta* <span class="badge bg-green-100 text-green-700">Any-Angle Planning</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Problem with A*:</strong> Paths constrained to grid edges (zigzag).
                            <strong>Theta* fix:</strong> Check <strong>line-of-sight</strong> to grandparent.
                            <ul>
                                <li>If parent's parent is visible → connect directly (shortcut)</li>
                                <li>Results in smoother, shorter paths</li>
                            </ul>
                            <code>if lineOfSight(parent(s), s'): parent(s') = parent(s)</code>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Show A* zigzag vs Theta* diagonal shortcut.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            D* Lite <span class="badge bg-purple-100 text-purple-700">Incremental Replanning</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Key idea:</strong> Efficiently replan when map changes (dynamic environments).
                            <ul>
                                <li><strong>g(s):</strong> Current cost estimate</li>
                                <li><strong>rhs(s):</strong> One-step lookahead cost</li>
                                <li><strong>Consistent:</strong> g(s) = rhs(s)</li>
                                <li><strong>Inconsistent:</strong> g(s) ≠ rhs(s) → needs update</li>
                            </ul>
                            <strong>Plans backward</strong> (goal→start). Only updates affected nodes.
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Show obstacle appearing, only nearby nodes being updated.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            JPS <span class="badge bg-amber-100 text-amber-700">Jump Point Search</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Key idea:</strong> A* optimization for uniform-cost grids. Prunes symmetric paths by "jumping" over intermediate nodes.
                            <ul>
                                <li><strong>Jump Points:</strong> Nodes where path direction must change</li>
                                <li><strong>Forced Neighbors:</strong> Neighbors that become relevant due to obstacles</li>
                                <li><strong>Pruning:</strong> Skip nodes reachable optimally via parent</li>
                            </ul>
                            <strong>Same optimality as A*</strong>, but explores far fewer nodes.
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Show jumping over empty cells, stopping at forced neighbors.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            Key Concepts <span class="badge bg-gray-100 text-gray-700">C-Space & More</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Configuration Space (C):</strong> All possible robot poses.<br>
                            <strong>C<sub>free</sub>:</strong> Collision-free configurations.<br>
                            <strong>Minkowski Sum:</strong> For disk robot radius r, expand obstacles by r.<br>
                            <strong>Distance Transform:</strong> Each cell stores distance to nearest obstacle (brushfire algorithm).<br>
                            <strong>Visibility Graph:</strong> Connect visible obstacle corners → shortest polygonal path.
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">Heuristics</div>
                        <div class="algo-explain-text">
                            <strong>Euclidean:</strong> √[(Δx)² + (Δy)²] - admissible<br>
                            <strong>Manhattan:</strong> |Δx| + |Δy| - admissible for 4-connected<br>
                            <strong>Diagonal:</strong> max(|Δx|, |Δy|) + (√2-1)·min(|Δx|, |Δy|)
                        </div>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="gridCanvas" width="500" height="500"></canvas>
            </div>

            <div class="sidebar">
                <div class="tab-header">
                    <div class="tab-btn active" onclick="switchGridTab('CTRL')" id="tab-GRID-CTRL">Planning</div>
                    <div class="tab-btn" onclick="switchGridTab('CSPACE')" id="tab-GRID-CSPACE">C-Space</div>
                    <div class="tab-btn" onclick="switchGridTab('DTRANS')" id="tab-GRID-DTRANS">Dist Trans</div>
                    <div class="tab-btn" onclick="switchGridTab('VISGRAPH')" id="tab-GRID-VISGRAPH">Vis Graph</div>
                    <div class="tab-btn" onclick="switchGridTab('EDU')" id="tab-GRID-EDU">Guide</div>
                </div>

                <div class="sidebar-scroll">
                    <!-- Grid Controls -->
                    <div id="section-GRID-CTRL" class="sidebar-content algo-section active">
                        <h2 class="text-xl font-bold text-gray-800 mb-2">Grid Planner</h2>
                        
                        <!-- Algo Switch -->
                        <div class="flex items-center justify-between bg-gray-50 p-2 rounded mb-4">
                            <span class="text-sm font-semibold text-gray-700">Algorithm</span>
                            <div class="flex bg-gray-200 rounded p-1">
                                <button onclick="setGridAlgo('ASTAR')" id="btn-grid-astar" class="px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600">A*</button>
                                <button onclick="setGridAlgo('THETA')" id="btn-grid-theta" class="px-2 py-1 text-xs rounded text-gray-600">Theta*</button>
                                <button onclick="setGridAlgo('JPS')" id="btn-grid-jps" class="px-2 py-1 text-xs rounded text-gray-600">JPS</button>
                                <button onclick="setGridAlgo('DLITE')" id="btn-grid-dlite" class="px-2 py-1 text-xs rounded text-gray-600">D* Lite</button>
                            </div>
                        </div>

                        <!-- Instructions -->
                        <div class="space-y-1 text-sm text-gray-600 mb-4">
                            <p><strong>Left Click:</strong> Toggle Wall <span id="dlite-hint" class="hidden text-red-500 font-bold text-xs">(Trigger Replanning)</span></p>
                            <p><strong>Right Click:</strong> Move Start</p>
                            <p><strong>Shift + Click:</strong> Move Goal</p>
                        </div>

                        <!-- Algorithm Steps Visualization -->
                        <div id="grid-steps-container" class="mb-4">
                            <!-- A* / Theta Steps -->
                            <div class="grid-astar-section">
                                <div id="step-grid-1" class="step-item">1. Pop Lowest F Node (Pick Best)</div>
                                <div id="step-grid-2" class="step-item">2. Check if Goal Reached</div>
                                <div id="step-grid-3" class="step-item">3. Expand Neighbors (Explore)</div>
                                <div id="step-grid-4" class="step-item grid-theta-only">3a. Check Line-of-Sight (Theta*)</div>
                                <div id="step-grid-5" class="step-item">4. Update Costs & Parent</div>
                            </div>
                            
                            <!-- JPS Steps -->
                            <div class="grid-jps-section" style="display: none;">
                                <div class="text-xs bg-amber-100 text-amber-800 p-1 mb-2 rounded border border-amber-200">
                                    Jump Point Search: Prunes symmetric paths
                                </div>
                                <div id="step-jps-1" class="step-item">1. Pop Lowest F Node</div>
                                <div id="step-jps-2" class="step-item">2. Check if Goal Reached</div>
                                <div id="step-jps-3" class="step-item">3. Identify Successors (Jump)</div>
                                <div id="step-jps-4" class="step-item">4. Find Jump Points</div>
                                <div id="step-jps-5" class="step-item">5. Update Costs & Parent</div>
                            </div>

                            <!-- D* Lite Steps -->
                            <div class="grid-dlite-section">
                                <div class="text-xs bg-yellow-100 text-yellow-800 p-1 mb-2 rounded border border-yellow-200">
                                    Backward Search: Goal &rarr; Start
                                </div>
                                <div id="step-dlite-1" class="step-item">1. Pop Min Key (Priority Queue)</div>
                                <div id="step-dlite-2" class="step-item">2. Consistency Check (g vs rhs)</div>
                                <div id="step-dlite-3" class="step-item">3. Update Neighbors (Predecessors)</div>
                                <div id="step-dlite-4" class="step-item">4. Update Keys & Re-insert</div>
                            </div>
                        </div>

                        <div class="mt-auto p-3 bg-blue-50 border border-blue-100 rounded text-sm text-blue-900">
                            <p class="font-bold text-xs uppercase text-blue-500 mb-1">Results</p>
                            <p><strong>Path Cost:</strong> <span id="grid-cost">0</span></p>
                            <p><strong>Visited Nodes:</strong> <span id="grid-visited">0</span></p>
                            <p class="mt-2 text-xs font-mono text-gray-500" id="algo-status">Ready</p>
                        </div>
                    </div>

                    <!-- C-Space Visualization -->
                    <div id="section-GRID-CSPACE" class="sidebar-content algo-section">
                        <h2 class="text-xl font-bold text-gray-800 mb-2">Configuration Space</h2>
                        <p class="text-xs text-gray-500 mb-4">Workspace → C-space transformation</p>

                        <!-- Robot Size Slider -->
                        <div class="flex items-center justify-between bg-gray-50 p-2 rounded mb-4">
                            <span class="text-sm font-semibold text-gray-700">Robot Radius</span>
                            <div class="flex items-center gap-2">
                                <input type="range" min="1" max="5" value="2" id="robot-radius-slider" class="w-20" oninput="updateRobotRadius(this.value)">
                                <span class="text-xs font-mono w-6" id="robot-radius-val">2</span>
                            </div>
                        </div>

                        <!-- View Toggle -->
                        <div class="flex items-center justify-between bg-gray-50 p-2 rounded mb-4">
                            <span class="text-sm font-semibold text-gray-700">View</span>
                            <div class="flex bg-gray-200 rounded p-1">
                                <button onclick="setCSpaceView('WORKSPACE')" id="btn-view-workspace" class="px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600">Workspace</button>
                                <button onclick="setCSpaceView('CSPACE')" id="btn-view-cspace" class="px-2 py-1 text-xs rounded text-gray-600">C-Space</button>
                                <button onclick="setCSpaceView('BOTH')" id="btn-view-both" class="px-2 py-1 text-xs rounded text-gray-600">Both</button>
                            </div>
                        </div>

                        <!-- Legend -->
                        <div class="p-3 bg-gray-50 rounded text-xs mb-4">
                            <p class="font-bold mb-2">Legend:</p>
                            <div class="space-y-1">
                                <div class="flex items-center gap-2"><span class="w-4 h-4 bg-gray-700 rounded"></span> Original Obstacle</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-4 bg-red-300 rounded"></span> C-obstacle (expanded)</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-4 bg-blue-500 rounded-full"></span> Robot (disk)</div>
                                <div class="flex items-center gap-2"><span class="w-2 h-2 bg-blue-800 rounded-full"></span> Robot in C-space (point)</div>
                            </div>
                        </div>

                        <!-- Explanation -->
                        <div class="p-3 bg-indigo-50 border border-indigo-100 rounded text-xs text-indigo-900">
                            <p class="font-bold mb-1">How C-space works:</p>
                            <p>For a <strong>disk robot</strong> with radius r, obstacles are <strong>expanded by r</strong> (Minkowski sum).</p>
                            <p class="mt-1">The robot becomes a <strong>point</strong> in C-space. If the point is in C<sub>free</sub>, the disk robot doesn't collide.</p>
                            <p class="mt-2 italic">"Překážky se zvětší o poloměr robota."</p>
                        </div>
                    </div>

                    <!-- Distance Transform -->
                    <div id="section-GRID-DTRANS" class="sidebar-content algo-section">
                        <h2 class="text-xl font-bold text-gray-800 mb-2">Distance Transform</h2>
                        <p class="text-xs text-gray-500 mb-4">Brushfire algorithm visualization</p>

                        <!-- Color Scale Legend -->
                        <div class="p-3 bg-gray-50 rounded text-xs mb-4">
                            <p class="font-bold mb-2">Distance Color Scale:</p>
                            <div class="flex items-center gap-1 mb-2">
                                <div class="h-4 flex-1 rounded" style="background: linear-gradient(to right, #ef4444, #f97316, #eab308, #22c55e, #3b82f6, #8b5cf6)"></div>
                            </div>
                            <div class="flex justify-between text-[10px] text-gray-500">
                                <span>0 (Obstacle)</span>
                                <span>Max Distance</span>
                            </div>
                        </div>

                        <!-- View Mode -->
                        <div class="flex items-center justify-between bg-gray-50 p-2 rounded mb-4">
                            <span class="text-sm font-semibold text-gray-700">View Mode</span>
                            <div class="flex bg-gray-200 rounded p-1">
                                <button onclick="setDTransView('DISTANCE')" id="btn-dtrans-dist" class="px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600">Distance</button>
                                <button onclick="setDTransView('GRADIENT')" id="btn-dtrans-grad" class="px-2 py-1 text-xs rounded text-gray-600">Gradient</button>
                            </div>
                        </div>

                        <!-- Animate Brushfire -->
                        <div class="mb-4">
                            <button onclick="animateBrushfire()" id="btn-brushfire" class="w-full px-3 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded text-sm font-bold">
                                ▶ Animate Brushfire
                            </button>
                            <p class="text-[10px] text-gray-500 mt-1 text-center">Watch wavefront expand from obstacles</p>
                        </div>

                        <!-- Stats -->
                        <div class="p-3 bg-blue-50 border border-blue-100 rounded text-sm mb-4">
                            <p><strong>Max Distance:</strong> <span id="dtrans-max">0</span> cells</p>
                            <p><strong>Safest Point:</strong> <span id="dtrans-safest">(0, 0)</span></p>
                        </div>

                        <!-- Explanation -->
                        <div class="p-3 bg-indigo-50 border border-indigo-100 rounded text-xs text-indigo-900">
                            <p class="font-bold mb-1">What is Distance Transform?</p>
                            <p>Each cell stores distance to <strong>nearest obstacle</strong>.</p>
                            <p class="mt-1"><strong>Brushfire Algorithm:</strong> BFS wavefront from all obstacles simultaneously. Layer by layer expansion.</p>
                            <p class="mt-1"><strong>Applications:</strong></p>
                            <ul class="list-disc pl-4 mt-1">
                                <li>Path planning with clearance (stay away from walls)</li>
                                <li>Voronoi diagram approximation (ridges = equidistant)</li>
                                <li>Navigation functions</li>
                            </ul>
                            <p class="mt-2 italic">"Vzdálenost ke stěnám pro bezpečné plánování."</p>
                        </div>
                    </div>

                    <!-- Visibility Graph / Voronoi -->
                    <div id="section-GRID-VISGRAPH" class="sidebar-content algo-section">
                        <h2 class="text-xl font-bold text-gray-800 mb-2">Visibility Graph & Voronoi</h2>
                        <p class="text-xs text-gray-500 mb-4">Geometric path planning methods</p>

                        <!-- View Mode -->
                        <div class="flex items-center justify-between bg-gray-50 p-2 rounded mb-4">
                            <span class="text-sm font-semibold text-gray-700">View Mode</span>
                            <div class="flex bg-gray-200 rounded p-1">
                                <button onclick="setVisGraphView('VISGRAPH')" id="btn-visgraph-vg" class="px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600">Vis Graph</button>
                                <button onclick="setVisGraphView('VORONOI')" id="btn-visgraph-vor" class="px-2 py-1 text-xs rounded text-gray-600">Voronoi</button>
                            </div>
                        </div>

                        <!-- Toggle options -->
                        <div class="space-y-2 mb-4">
                            <label class="flex items-center gap-2 text-sm">
                                <input type="checkbox" id="visgraph-show-path" onchange="drawGridScene()" checked>
                                <span>Show shortest path</span>
                            </label>
                            <label class="flex items-center gap-2 text-sm">
                                <input type="checkbox" id="visgraph-show-all" onchange="drawGridScene()">
                                <span>Show all edges</span>
                            </label>
                        </div>

                        <!-- Legend - Visibility Graph -->
                        <div id="visgraph-legend-vg" class="p-3 bg-gray-50 rounded text-xs mb-4">
                            <p class="font-bold mb-2">Visibility Graph Legend:</p>
                            <div class="space-y-1">
                                <div class="flex items-center gap-2"><span class="w-3 h-3 bg-yellow-400 rounded-full"></span> Vertex (obstacle corner)</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-1 bg-gray-400"></span> Visibility edge</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-1 bg-green-500" style="height:3px"></span> Shortest path</div>
                                <div class="flex items-center gap-2"><span class="w-3 h-3 bg-blue-500 rounded-full"></span> Start</div>
                                <div class="flex items-center gap-2"><span class="w-3 h-3 bg-red-500 rounded-full"></span> Goal</div>
                            </div>
                        </div>

                        <!-- Legend - Voronoi -->
                        <div id="visgraph-legend-vor" class="p-3 bg-gray-50 rounded text-xs mb-4 hidden">
                            <p class="font-bold mb-2">Voronoi Diagram Legend:</p>
                            <div class="space-y-1">
                                <div class="flex items-center gap-2"><span class="w-4 h-1 bg-cyan-400" style="height:2px"></span> Voronoi edge (equidistant)</div>
                                <div class="flex items-center gap-2"><span class="w-4 h-1 bg-green-500" style="height:3px"></span> Path along Voronoi</div>
                                <div class="flex items-center gap-2"><span class="w-3 h-3 bg-gray-600 rounded"></span> Obstacle</div>
                            </div>
                            <p class="mt-2 text-[10px] text-gray-500">Voronoi edges maximize clearance from obstacles</p>
                        </div>

                        <!-- Explanation - Visibility Graph -->
                        <div id="visgraph-exp-vg" class="p-3 bg-indigo-50 border border-indigo-100 rounded text-xs text-indigo-900 mb-3">
                            <p class="font-bold mb-1">What is a Visibility Graph?</p>
                            <p><strong>Vertices:</strong> Start, Goal, and all obstacle corners (convex hull vertices).</p>
                            <p class="mt-1"><strong>Edges:</strong> Connect vertices if the line segment doesn't intersect any obstacle interior.</p>
                            <p class="mt-1"><strong>Shortest path:</strong> Run Dijkstra/A* on the graph. The result is the optimal path among all polygonal paths.</p>
                            <p class="mt-2"><strong>Complexity:</strong> O(n² log n) where n = number of vertices.</p>
                            <p class="mt-2 italic">"Spojíme viditelné rohy - nejkratší cesta je na hranách."</p>
                        </div>

                        <!-- Explanation - Voronoi -->
                        <div id="visgraph-exp-vor" class="p-3 bg-purple-50 border border-purple-100 rounded text-xs text-purple-900 hidden">
                            <p class="font-bold mb-1">What is a Voronoi Diagram?</p>
                            <p><strong>Definition:</strong> Partitions space into regions closest to each obstacle.</p>
                            <p class="mt-1"><strong>Edges:</strong> Points equidistant from two or more obstacles.</p>
                            <p class="mt-1"><strong>For path planning:</strong> Path along Voronoi edges maximizes clearance from obstacles (safest path).</p>
                            <p class="mt-2"><strong>Approximation:</strong> Ridge detection on Distance Transform gives Voronoi-like skeleton.</p>
                            <p class="mt-2 italic">"Voroného diagram = maximální vzdálenost od překážek."</p>
                        </div>

                        <!-- Comparison -->
                        <div class="p-3 bg-amber-50 border border-amber-100 rounded text-xs text-amber-900">
                            <p class="font-bold mb-1">Vis Graph vs Voronoi:</p>
                            <table class="w-full text-[10px] mt-1">
                                <tr><td class="font-bold pr-2">Vis Graph:</td><td>Shortest path, touches obstacles</td></tr>
                                <tr><td class="font-bold pr-2">Voronoi:</td><td>Safest path, max clearance</td></tr>
                            </table>
                        </div>
                    </div>

                    <!-- Grid Education -->
                    <div id="section-GRID-EDU" class="sidebar-content algo-section">
                        <h2 class="text-xl font-bold text-gray-800 mb-4">Exam Questions & Answers</h2>

                        <div class="edu-card">
                            <div class="edu-title">1. Define C and C<sub>free</sub>.</div>
                            <div class="edu-text">
                                <strong>C (Configuration Space):</strong> The set of all possible poses (configurations) of the robot.<br>
                                <strong>C<sub>free</sub>:</strong> The subset of C where the robot does not collide with obstacles.<br>
                                <strong>C<sub>obs</sub>:</strong> C \ C<sub>free</sub> - configurations in collision.<br>
                                <em>"C = všechny pózy, Cfree = pózy bez kolize."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">2. What is a path vs trajectory?</div>
                            <div class="edu-text">
                                <strong>Path:</strong> A continuous curve σ: [0,1] → C<sub>free</sub> from start to goal. No time information.<br>
                                <strong>Trajectory:</strong> A path with timing information σ(t), specifying when robot is at each configuration.<br>
                                <em>"Cesta = geometrie, trajektorie = cesta + čas."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">3. Characterize grid-based planning?</div>
                            <div class="edu-text">
                                Methods that discretize the continuous world into a grid (matrix). The problem is converted into a graph search (nodes = cells, edges = adjacency). Standard algorithms like A* or Dijkstra are used.<br>
                                <em>"Diskretizace světa na mřížku + prohledávání grafu."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">4. A* Algorithm - f(n) = g(n) + h(n)</div>
                            <div class="edu-text">
                                <strong>g(n):</strong> Cost from start to node n (actual)<br>
                                <strong>h(n):</strong> Heuristic estimate from n to goal<br>
                                <strong>f(n):</strong> Total estimated cost through n<br>
                                A* expands node with lowest f(n). Optimal if h is admissible (never overestimates).<br>
                                <em>"f = g + h, vybíráme nejmenší f."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">5. Sketch Theta* vs A*.</div>
                            <div class="edu-text">
                                <strong>A*:</strong> Path constrained to grid edges (zigzag).<br>
                                <strong>Theta*:</strong> "Any-angle" planning. Checks line-of-sight to the <em>parent's parent</em>. If visible, creates shortcut diagonal edge.<br>
                                <code>if lineOfSight(parent(s), s'):<br>&nbsp;&nbsp;parent(s') = parent(s)</code><br>
                                <em>"Theta* vidí 'zkratku' přes souseda."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">5b. What is Jump Point Search (JPS)?</div>
                            <div class="edu-text">
                                A* optimization for uniform-cost grids that prunes symmetric paths.<br>
                                <strong>Key concepts:</strong>
                                <ul class="list-disc pl-4 mt-1">
                                    <li><strong>Jump Points:</strong> Nodes where direction must change</li>
                                    <li><strong>Forced Neighbors:</strong> Neighbors revealed by obstacles</li>
                                    <li><strong>Pruning:</strong> Skip nodes reachable via parent</li>
                                </ul>
                                Instead of expanding all neighbors, "jump" until hitting a wall, goal, or forced neighbor.<br>
                                <strong>Same optimal path as A*</strong>, but explores far fewer nodes.<br>
                                <em>"Skáče přes prázdné buňky, zastaví u překážek."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">6. Main idea of D* Lite?</div>
                            <div class="edu-text">
                                Incremental heuristic search for dynamic environments.<br>
                                <strong>Key concepts:</strong>
                                <ul class="list-disc pl-4 mt-1">
                                    <li><strong>g(s):</strong> Current cost estimate</li>
                                    <li><strong>rhs(s):</strong> One-step lookahead cost</li>
                                    <li><strong>Consistent:</strong> g(s) = rhs(s)</li>
                                    <li><strong>Inconsistent:</strong> g(s) ≠ rhs(s) → needs update</li>
                                </ul>
                                Plans backward (goal→start). On map change, only updates inconsistent nodes.<br>
                                <em>"Inkrementální - přepočítá jen nutné minimum."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">7. What is Bresenham's line algorithm?</div>
                            <div class="edu-text">
                                Efficient algorithm to determine which grid cells a line passes through.
                                Used in path planning for:
                                <ul class="list-disc pl-4 mt-1">
                                    <li>Line-of-sight checks (Theta*)</li>
                                    <li>Collision detection on grids</li>
                                    <li>Ray casting for sensor simulation</li>
                                </ul>
                                <em>"Které buňky protíná úsečka?"</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">8. What is Distance Transform?</div>
                            <div class="edu-text">
                                Computes distance from each free cell to nearest obstacle.
                                <strong>For path planning:</strong> Propagate distance from goal, then follow gradient descent.<br>
                                <strong>Benefits:</strong> Simple, no explicit graph needed.<br>
                                <strong>Drawback:</strong> May not find optimal path on discretized grid.<br>
                                <em>"Vzdálenost od překážek → gradient k cíli."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">9. Jump Point Search (JPS)?</div>
                            <div class="edu-text">
                                Optimization of A* for uniform-cost grids.
                                <strong>Key idea:</strong> Skip intermediate nodes by "jumping" to important points (corners, direction changes).
                                <strong>Much faster</strong> than A* on large open grids - same optimality.<br>
                                <em>"Přeskakuje nudné uzly, hledá důležité body."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">10. Visibility Graph vs Voronoi Diagram?</div>
                            <div class="edu-text">
                                <strong>Visibility Graph:</strong> Connects obstacle vertices if visible. Shortest path but close to obstacles.<br>
                                <strong>Voronoi Diagram:</strong> Path maximally far from all obstacles. Safer but longer path.<br>
                                <em>"Visibility = nejkratší, Voronoi = nejbezpečnější."</em>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== VIEW 4: EXPLORATION ==================== -->
        <div id="view-EXPLORE" class="view-section">
            <!-- Left Explanation Sidebar -->
            <div class="left-sidebar">
                <div class="left-sidebar-header">Autonomous Exploration</div>
                <div class="left-sidebar-content">
                    <div class="algo-intro">
                        <p><strong>What is it?</strong> Robot explores unknown environment, building a map while deciding where to go next. Combines mapping, localization, and planning.</p>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            Occupancy Grid <span class="badge bg-blue-100 text-blue-700">Probabilistic Map</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Idea:</strong> Grid where each cell stores <strong>probability of being occupied</strong>.
                            <ul>
                                <li><strong>P(m) = 0.5:</strong> Unknown</li>
                                <li><strong>P(m) → 1:</strong> Likely occupied</li>
                                <li><strong>P(m) → 0:</strong> Likely free</li>
                            </ul>
                            <strong>Update:</strong> Use log-odds for numerical stability:<br>
                            <code>l(m) = log(P(m)/(1-P(m)))</code>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Grid with cells colored: black=occupied, white=free, gray=unknown.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            Sensor Models <span class="badge bg-green-100 text-green-700">Laser vs Sonar</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Laser (narrow beam):</strong>
                            <ul>
                                <li>Cells along ray → decrease P(occupied)</li>
                                <li>Cell at endpoint → increase P(occupied)</li>
                                <li>High accuracy, narrow cone</li>
                            </ul>
                            <strong>Sonar (wide beam):</strong>
                            <ul>
                                <li>Wide cone of uncertainty</li>
                                <li>Can't tell exactly where obstacle is within cone</li>
                                <li>Multiple readings needed to narrow down</li>
                            </ul>
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Laser = thin line. Sonar = wide cone/arc.</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            Frontier-Based <span class="badge bg-purple-100 text-purple-700">Exploration Strategy</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Frontier:</strong> Boundary between <strong>known-free</strong> and <strong>unknown</strong> regions.
                            <ul>
                                <li>Detect frontier cells (free cell adjacent to unknown)</li>
                                <li>Cluster frontiers into regions</li>
                                <li>Select best frontier (nearest, largest, most info gain)</li>
                                <li>Plan path to frontier, execute, repeat</li>
                            </ul>
                            <strong>Stopping:</strong> No more frontiers = map complete!
                            <div class="sketch-hint">✏️ <strong>Sketch:</strong> Map with known area, frontier cells highlighted at boundary with gray (unknown).</div>
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">
                            Information Gain <span class="badge bg-orange-100 text-orange-700">Smart Selection</span>
                        </div>
                        <div class="algo-explain-text">
                            <strong>Problem:</strong> Which frontier to visit?
                            <ul>
                                <li><strong>Nearest:</strong> Minimize travel (greedy)</li>
                                <li><strong>Largest:</strong> More area to explore</li>
                                <li><strong>Info gain:</strong> Expected reduction in map entropy</li>
                                <li><strong>Combined:</strong> gain/cost ratio</li>
                            </ul>
                            <strong>Entropy:</strong> H = -Σ P(m)·log(P(m)) - measures uncertainty
                        </div>
                    </div>

                    <div class="algo-explain">
                        <div class="algo-explain-title">Key Terms</div>
                        <div class="algo-explain-text">
                            <strong>SLAM:</strong> Simultaneous Localization And Mapping<br>
                            <strong>Ray casting:</strong> Trace sensor beam through grid<br>
                            <strong>Coverage:</strong> % of environment mapped<br>
                            <strong>Next-Best-View:</strong> Where to look next for max info
                        </div>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="exploreCanvas" width="500" height="500"></canvas>
            </div>

            <div class="sidebar">
                <div class="tab-header">
                    <div class="tab-btn active" onclick="switchExploreTab('CTRL')" id="tab-EXPLORE-CTRL">Simulation</div>
                    <div class="tab-btn" onclick="switchExploreTab('EDU')" id="tab-EXPLORE-EDU">Topic Guide</div>
                </div>

                <div class="sidebar-scroll">
                    <!-- Explore Controls -->
                    <div id="section-EXPLORE-CTRL" class="sidebar-content algo-section active">
                        <h2 class="text-xl font-bold text-gray-800 mb-2">Frontier Exploration</h2>
                        <p class="text-xs text-gray-500 mb-4">Occupancy Grid + Frontier-based</p>

                        <!-- Mode Switch -->
                        <div class="flex items-center justify-between bg-gray-50 p-2 rounded mb-4">
                            <span class="text-sm font-semibold text-gray-700">Sensor</span>
                            <div class="flex bg-gray-200 rounded p-1">
                                <button onclick="setExploreSensor('LASER')" id="btn-sensor-laser" class="px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600">Laser</button>
                                <button onclick="setExploreSensor('SONAR')" id="btn-sensor-sonar" class="px-3 py-1 text-xs rounded text-gray-600">Sonar</button>
                            </div>
                        </div>

                        <!-- Instructions -->
                        <div class="space-y-1 text-sm text-gray-600 mb-4">
                            <p><strong>Click canvas:</strong> Move robot to location</p>
                            <p><strong>Play:</strong> Auto-explore (find frontiers)</p>
                            <p><strong>Reset:</strong> New random environment</p>
                        </div>

                        <!-- Exploration Steps -->
                        <div class="mb-4">
                            <div id="step-explore-1" class="step-item">1. Sense Environment (Ray cast)</div>
                            <div id="step-explore-2" class="step-item">2. Update Occupancy Grid</div>
                            <div id="step-explore-3" class="step-item">3. Detect Frontiers</div>
                            <div id="step-explore-4" class="step-item">4. Select Best Frontier</div>
                            <div id="step-explore-5" class="step-item">5. Navigate to Frontier</div>
                        </div>

                        <!-- Legend -->
                        <div class="p-3 bg-gray-50 rounded text-xs mb-4">
                            <p class="font-bold mb-2">Legend:</p>
                            <div class="flex flex-wrap gap-2">
                                <span class="flex items-center gap-1"><span class="w-3 h-3 bg-gray-700 rounded"></span> Obstacle</span>
                                <span class="flex items-center gap-1"><span class="w-3 h-3 bg-white border rounded"></span> Free</span>
                                <span class="flex items-center gap-1"><span class="w-3 h-3 bg-gray-300 rounded"></span> Unknown</span>
                                <span class="flex items-center gap-1"><span class="w-3 h-3 bg-orange-400 rounded"></span> Frontier</span>
                            </div>
                        </div>

                        <div class="mt-auto p-3 bg-green-50 border border-green-100 rounded text-sm text-green-900">
                            <p class="font-bold text-xs uppercase text-green-500 mb-1">Stats</p>
                            <p><strong>Explored:</strong> <span id="explore-percent">0</span>%</p>
                            <p><strong>Frontiers:</strong> <span id="frontier-count">0</span></p>
                            <p class="mt-2 text-xs font-mono text-gray-500" id="explore-status">Ready</p>
                        </div>
                    </div>

                    <!-- Explore Education -->
                    <div id="section-EXPLORE-EDU" class="sidebar-content algo-section">
                        <h2 class="text-xl font-bold text-gray-800 mb-4">Exam Questions & Answers</h2>

                        <div class="edu-card">
                            <div class="edu-title">1. What is an Occupancy Grid Map?</div>
                            <div class="edu-text">
                                Grid representation where each cell stores probability of being occupied.
                                <ul class="list-disc pl-4 mt-1">
                                    <li>P(occupied) = 0 → definitely free</li>
                                    <li>P(occupied) = 1 → definitely obstacle</li>
                                    <li>P(occupied) = 0.5 → unknown</li>
                                </ul>
                                <em>"Mřížka s pravděpodobností obsazení."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">2. Occupancy Grid Assumptions?</div>
                            <div class="edu-text">
                                <ol class="list-decimal pl-4">
                                    <li>Cells are completely free OR occupied (binary)</li>
                                    <li>Cells are independent of each other</li>
                                    <li>Environment is static</li>
                                </ol>
                                <em>"Buňky nezávislé, binární, statické prostředí."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">3. Sonar vs Laser Sensor Model?</div>
                            <div class="edu-text">
                                <strong>Sonar:</strong> Wide beam angle (cone), lower accuracy, can detect glass.<br>
                                <strong>Laser:</strong> Narrow beam, high accuracy, may miss transparent objects.<br>
                                Update: Use log-odds for numerical stability.<br>
                                <em>"Sonar = široký kužel, Laser = úzký paprsek."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">4. What is a Frontier?</div>
                            <div class="edu-text">
                                Boundary between <strong>known free space</strong> and <strong>unknown space</strong>.<br>
                                Frontiers represent areas worth exploring.
                                <br><em>"Hranice mezi známým volným a neznámým prostorem."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">5. Frontier-based Exploration Algorithm?</div>
                            <div class="edu-text">
                                <ol class="list-decimal pl-4">
                                    <li>Sense and update map</li>
                                    <li>Detect frontier cells</li>
                                    <li>Cluster frontiers into regions</li>
                                    <li>Select best frontier (size, distance, info gain)</li>
                                    <li>Navigate to selected frontier</li>
                                    <li>Repeat until no frontiers remain</li>
                                </ol>
                                <em>"Opakovaně hledej a navštěvuj hranice."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">6. Multi-robot Exploration Challenges?</div>
                            <div class="edu-text">
                                <ul class="list-disc pl-4">
                                    <li>Task allocation (who explores where?)</li>
                                    <li>Map merging and alignment</li>
                                    <li>Communication constraints</li>
                                    <li>Avoiding redundant exploration</li>
                                </ul>
                                <em>"Koordinace, sdílení map, vyhnutí se redundanci."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">7. Multi-robot Exploration Strategies?</div>
                            <div class="edu-text">
                                <strong>Market-based:</strong> Robots bid on frontiers, auction assigns tasks.<br>
                                <strong>Potential field:</strong> Robots repel each other, attract to frontiers.<br>
                                <strong>Greedy assignment:</strong> Each robot takes nearest unassigned frontier.<br>
                                <em>"Aukce, potenciálová pole, nebo greedy přiřazení."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">8. Log-odds Update for Occupancy?</div>
                            <div class="edu-text">
                                <code>l(m|z) = l(m|z<sub>t</sub>) + l(m) - l<sub>0</sub></code><br>
                                Where l = log(p/(1-p)). Avoids numerical issues with multiplying small probabilities.<br>
                                <em>"Log-odds pro numerickou stabilitu."</em>
                            </div>
                        </div>

                        <div class="edu-card">
                            <div class="edu-title">9. Information Gain in Exploration?</div>
                            <div class="edu-text">
                                Expected reduction in uncertainty (entropy) from visiting a frontier.
                                <br><code>IG(f) = H(map) - H(map | visit f)</code><br>
                                Frontiers with high information gain are preferred.<br>
                                <em>"Očekávané snížení entropie mapy."</em>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- GLOBAL CONTROLS BAR -->
    <div class="controls-bar">
        
        <!-- RRT Specific Controls -->
        <div id="controls-RRT-SPECIFIC" class="flex items-center gap-4">
             <div id="rrt-toggle-group" class="flex items-center bg-gray-100 p-2 rounded-lg">
                <span class="mr-3 text-sm font-bold text-gray-700">Mode:</span>
                <div class="flex bg-gray-200 rounded p-1">
                    <button onclick="setRRTMode('RRT')" id="btn-rrt-mode" class="px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600">RRT</button>
                    <button onclick="setRRTMode('RRT_STAR')" id="btn-rrtstar-mode" class="px-3 py-1 text-xs rounded text-gray-600">RRT*</button>
                    <button onclick="setRRTMode('RRG')" id="btn-rrg-mode" class="px-3 py-1 text-xs rounded text-gray-600">RRG</button>
                </div>
            </div>

            <div id="prm-slider-group" class="hidden items-center bg-gray-100 p-2 rounded-lg gap-2">
                <span class="text-sm font-bold text-gray-700">Samples:</span>
                <input type="range" min="50" max="400" value="150" step="10" class="w-24" oninput="updatePrmSamples(this.value)">
                <span class="text-sm font-mono" id="prmSampleVal">150</span>
            </div>
        </div>

        <!-- TSP Specific Controls -->
        <div id="controls-TSP-SPECIFIC" class="hidden flex items-center gap-4">
            <button onclick="randomizeTspMap()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded shadow text-sm">
                Random Goals
            </button>
            <div class="w-px h-8 bg-gray-300 mx-2"></div>
        </div>

        <!-- Grid Specific Controls -->
        <div id="controls-GRID-SPECIFIC" class="hidden flex items-center gap-4">
            <button onclick="clearGridWalls()" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded shadow text-sm">
                Clear Walls
            </button>
        </div>

        <!-- Exploration Specific Controls -->
        <div id="controls-EXPLORE-SPECIFIC" class="hidden flex items-center gap-4">
            <button onclick="resetExplore()" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded shadow text-sm">
                Reset Map
            </button>
            <button onclick="addRandomObstacles()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded shadow text-sm">
                Add Obstacles
            </button>
        </div>

        <!-- Speed Slider -->
        <div class="flex items-center gap-2 bg-gray-100 px-3 py-2 rounded-lg">
            <span class="text-xs font-bold text-gray-600">Speed:</span>
            <input type="range" id="speed-slider" min="1" max="100" value="50" class="w-20" oninput="updateSpeed(this.value)">
            <span class="text-xs font-mono w-8" id="speed-value">50</span>
        </div>

        <!-- Common Play Controls -->
        <div class="flex gap-2">
            <button onclick="stepGlobal()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded shadow flex items-center gap-2 text-sm">Step</button>
            <button onclick="playGlobal()" id="btn-play" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded shadow flex items-center gap-2 text-sm">Play</button>
            <button onclick="resetGlobal()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded shadow text-sm">Reset</button>
        </div>
    </div>

<script>
    // ==========================================
    // GLOBAL STATE & ROUTER
    // ==========================================
    const VIEWS = { SAMPLING: 'SAMPLING', TSP: 'TSP', GRID: 'GRID', EXPLORE: 'EXPLORE' };
    let currentView = VIEWS.SAMPLING;
    let playInterval = null;
    let animationSpeed = 50; // Default speed (1-100 scale, converted to ms delay)

    function updateSpeed(val) {
        animationSpeed = parseInt(val);
        document.getElementById('speed-value').textContent = val;
        // If playing, restart with new speed
        if(playInterval) {
            stopAuto();
            startAuto();
        }
    }

    function getIntervalDelay() {
        // Convert speed (1-100) to delay (500ms - 5ms)
        // Higher speed = lower delay
        return Math.max(5, 505 - animationSpeed * 5);
    }

    function switchMainView(view) {
        currentView = view;

        // Update Nav
        document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
        document.getElementById(`nav-${view}`).classList.add('active');

        // Update View Containers
        document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
        document.getElementById(`view-${view}`).classList.add('active');

        // Update Bottom Controls Visibility
        document.getElementById('controls-RRT-SPECIFIC').style.display = (view === VIEWS.SAMPLING) ? 'flex' : 'none';
        document.getElementById('controls-TSP-SPECIFIC').style.display = (view === VIEWS.TSP) ? 'flex' : 'none';
        document.getElementById('controls-GRID-SPECIFIC').style.display = (view === VIEWS.GRID) ? 'flex' : 'none';
        document.getElementById('controls-EXPLORE-SPECIFIC').style.display = (view === VIEWS.EXPLORE) ? 'flex' : 'none';

        stopAuto();

        // Initial Draw/Reset for that view
        if(view === VIEWS.SAMPLING) drawRrtScene();
        else if(view === VIEWS.TSP) {
            if(tspState.targets.length === 0) randomizeTspMap();
            drawTspScene();
        }
        else if(view === VIEWS.GRID) drawGridScene();
        else if(view === VIEWS.EXPLORE) drawExploreScene();
    }

    function stepGlobal() {
        if(currentView === VIEWS.SAMPLING) stepRrtOnce();
        else if(currentView === VIEWS.TSP) stepTspOnce();
        else if(currentView === VIEWS.GRID) stepGridOnce();
        else if(currentView === VIEWS.EXPLORE) stepExploreOnce();
    }

    function playGlobal() {
        if(playInterval) stopAuto();
        else startAuto();
    }

    function resetGlobal() {
        if(currentView === VIEWS.SAMPLING) resetRrt();
        else if(currentView === VIEWS.TSP) resetTsp();
        else if(currentView === VIEWS.GRID) resetGrid();
        else if(currentView === VIEWS.EXPLORE) resetExplore();
    }

    function startAuto() {
        const btn = document.getElementById('btn-play');
        btn.textContent = "Pause";
        btn.classList.replace('bg-green-600', 'bg-yellow-500');
        btn.classList.replace('hover:bg-green-700', 'hover:bg-yellow-600');

        playInterval = setInterval(() => {
            if(currentView === VIEWS.SAMPLING) {
                if(rrtState.algo === 'RRT') advanceRRT(); else advancePRM();
                drawRrtScene();
            } else if(currentView === VIEWS.TSP) {
                advanceTSP();
                drawTspScene();
            } else if(currentView === VIEWS.GRID) {
                advanceGrid();
                drawGridScene();
            } else if(currentView === VIEWS.EXPLORE) {
                advanceExplore();
                drawExploreScene();
            }
        }, getIntervalDelay());
    }

    function stopAuto() {
        if(playInterval) clearInterval(playInterval);
        playInterval = null;
        const btn = document.getElementById('btn-play');
        btn.textContent = "Play";
        btn.classList.replace('bg-yellow-500', 'bg-green-600');
        btn.classList.replace('hover:bg-yellow-600', 'hover:bg-green-700');
    }


    // ==========================================
    // PART 1: RRT / PRM LOGIC
    // ==========================================
    const rrtCanvas = document.getElementById('rrtCanvas');
    const rrtCtx = rrtCanvas.getContext('2d');
    
    // RRT Config
    const SIZE = 500;
    const START_POS = { x: 30, y: 470 };
    const GOAL_POS = { x: 470, y: 30 };
    const GOAL_THRESHOLD = 30;
    
    let obstacles = [
        { x: 150, y: 300, r: 50 }, { x: 350, y: 200, r: 60 },
        { x: 250, y: 250, r: 40 }, { x: 300, y: 400, r: 50 },
        { x: 100, y: 100, r: 30 }, { x: 400, y: 100, r: 30 }
    ];

    let rrtState = {
        algo: 'RRT', // 'RRT' or 'PRM'
        mode: 'RRT', // 'RRT' or 'RRT_STAR'
        nodes: [],
        path: [],
        currentState: 0,
        temp: { randPoint: null, newNode: null, nearNodes: [], rewiredNodes: [], frontier: [] },
        prmSamples: 150
    };

    class Node {
        constructor(x, y, parent = null) {
            this.x = x; this.y = y; this.parent = parent; 
            this.children = []; this.cost = 0; this.neighbors = [];
            this.g=0; this.f=0;
            if(parent) { 
                this.cost = parent.cost + Math.hypot(x-parent.x, y-parent.y);
                parent.children.push(this);
            }
        }
    }

    function resetRrt() {
        stopAuto();
        rrtState.nodes = (rrtState.algo === 'RRT') ? [new Node(START_POS.x, START_POS.y)] : [];
        rrtState.path = [];
        rrtState.currentState = 0;
        rrtState.temp = { randPoint: null, newNode: null, nearNodes: [], rewiredNodes: [], frontier: [] };
        
        // UI Reset
        document.querySelectorAll('.step-item').forEach(el => el.classList.remove('active'));
        document.getElementById('node-count').textContent = rrtState.nodes.length;
        document.getElementById('cost-count').textContent = '-';
        document.getElementById('status-text').textContent = 'Ready';
        
        drawRrtScene();
    }

    function stepRrtOnce() {
        stopAuto();
        if(rrtState.algo === 'RRT') advanceRRT(); else advancePRM();
        drawRrtScene();
    }

    function isInsideObstacle(x, y) {
        for(let obs of obstacles) {
            if(Math.hypot(x - obs.x, y - obs.y) <= obs.r) return true;
        }
        return false;
    }

    function checkCollision(p1, p2) {
        if (p2.x < 0 || p2.x > SIZE || p2.y < 0 || p2.y > SIZE) return true;
        const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        const steps = Math.ceil(dist / 5);
        for (let i = 0; i <= steps; i++) {
            let t = i / steps;
            let cx = p1.x + t * (p2.x - p1.x);
            let cy = p1.y + t * (p2.y - p1.y);
            for (let obs of obstacles) {
                if (Math.hypot(cx - obs.x, cy - obs.y) <= obs.r) return true;
            }
        }
        return false;
    }

    function advanceRRT() {
        if(rrtState.currentState === 6) return;
        if(rrtState.currentState === 0) rrtState.currentState = 1;

        const STEP_SIZE = 30;
        const NEIGHBOR_RADIUS = 60; // For RRT* neighbor search

        // Step 1: Sample random point (with goal bias)
        if(rrtState.currentState === 1) {
            let target = (Math.random() < 0.1) ? GOAL_POS : {x: Math.random()*SIZE, y:Math.random()*SIZE};
            rrtState.temp.randPoint = target;
            rrtState.temp.nearNodes = [];
            rrtState.temp.rewiredNodes = [];
            rrtState.currentState = 2;
            highlightStep('rrt', 1);
            return;
        }

        // Step 2: Find nearest node
        if(rrtState.currentState === 2) {
            let nearest = rrtState.nodes[0];
            let minDist = Infinity;
            for(let n of rrtState.nodes) {
                let d = Math.hypot(n.x - rrtState.temp.randPoint.x, n.y - rrtState.temp.randPoint.y);
                if(d < minDist) { minDist = d; nearest = n; }
            }
            rrtState.temp.nearest = nearest;
            rrtState.currentState = 3;
            highlightStep('rrt', 2);
            return;
        }

        // Step 3: Steer towards random point
        if(rrtState.currentState === 3) {
            let p1 = rrtState.temp.nearest;
            let p2 = rrtState.temp.randPoint;
            let dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
            let nx, ny;
            if(dist <= STEP_SIZE) { nx = p2.x; ny = p2.y; }
            else {
                let theta = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                nx = p1.x + STEP_SIZE * Math.cos(theta);
                ny = p1.y + STEP_SIZE * Math.sin(theta);
            }
            rrtState.temp.newNode = new Node(nx, ny, null);
            rrtState.currentState = 4;
            highlightStep('rrt', 3);
            return;
        }

        // Step 4: Check collision
        if(rrtState.currentState === 4) {
            if(checkCollision(rrtState.temp.nearest, rrtState.temp.newNode)) {
                // Collision - restart
                rrtState.currentState = 1;
                highlightStep('rrt', 4);
                return;
            }
            // No collision - proceed
            if(rrtState.mode === 'RRT_STAR' || rrtState.mode === 'RRG') {
                rrtState.currentState = 8; // Go to find neighbors step
            } else {
                rrtState.currentState = 5; // Basic RRT - just add to tree
            }
            highlightStep('rrt', 4);
            return;
        }

        // Step 5: Add to tree (basic RRT)
        if(rrtState.currentState === 5) {
            rrtState.temp.newNode.parent = rrtState.temp.nearest;
            rrtState.temp.newNode.cost = rrtState.temp.nearest.cost +
                Math.hypot(rrtState.temp.newNode.x - rrtState.temp.nearest.x,
                          rrtState.temp.newNode.y - rrtState.temp.nearest.y);
            rrtState.temp.nearest.children.push(rrtState.temp.newNode);
            rrtState.nodes.push(rrtState.temp.newNode);

            if(Math.hypot(rrtState.temp.newNode.x - GOAL_POS.x, rrtState.temp.newNode.y - GOAL_POS.y) < GOAL_THRESHOLD) {
                rrtState.currentState = 6;
                reconstructRRTPath();
                highlightStep('rrt', 6);
            } else {
                rrtState.currentState = 1;
            }
            highlightStep('rrt', 5);
            document.getElementById('node-count').textContent = rrtState.nodes.length;
            return;
        }

        // Step 8: Find neighbors within radius (RRT* and RRG)
        if(rrtState.currentState === 8) {
            rrtState.temp.nearNodes = [];
            for(let n of rrtState.nodes) {
                let d = Math.hypot(n.x - rrtState.temp.newNode.x, n.y - rrtState.temp.newNode.y);
                if(d < NEIGHBOR_RADIUS && !checkCollision(n, rrtState.temp.newNode)) {
                    rrtState.temp.nearNodes.push(n);
                }
            }

            // Choose best parent from neighbors
            let bestParent = rrtState.temp.nearest;
            let bestCost = rrtState.temp.nearest.cost +
                Math.hypot(rrtState.temp.newNode.x - rrtState.temp.nearest.x,
                          rrtState.temp.newNode.y - rrtState.temp.nearest.y);

            for(let neighbor of rrtState.temp.nearNodes) {
                let newCost = neighbor.cost +
                    Math.hypot(rrtState.temp.newNode.x - neighbor.x,
                              rrtState.temp.newNode.y - neighbor.y);
                if(newCost < bestCost) {
                    bestCost = newCost;
                    bestParent = neighbor;
                }
            }

            rrtState.temp.newNode.parent = bestParent;
            rrtState.temp.newNode.cost = bestCost;
            bestParent.children.push(rrtState.temp.newNode);
            rrtState.nodes.push(rrtState.temp.newNode);

            // RRG: Connect to ALL neighbors (create graph edges)
            if(rrtState.mode === 'RRG') {
                for(let neighbor of rrtState.temp.nearNodes) {
                    // Add bidirectional neighbor edges (for graph visualization)
                    if(!rrtState.temp.newNode.neighbors.includes(neighbor)) {
                        rrtState.temp.newNode.neighbors.push(neighbor);
                    }
                    if(!neighbor.neighbors.includes(rrtState.temp.newNode)) {
                        neighbor.neighbors.push(rrtState.temp.newNode);
                    }
                }
            }

            highlightStep('rrt', 8);
            rrtState.currentState = 9; // Go to rewire step
            document.getElementById('node-count').textContent = rrtState.nodes.length;
            return;
        }

        // Step 9: Rewire neighbors (RRT* only, skip for RRG)
        if(rrtState.currentState === 9) {
            rrtState.temp.rewiredNodes = [];

            // RRT*: Rewire to improve costs
            if(rrtState.mode === 'RRT_STAR') {
                for(let neighbor of rrtState.temp.nearNodes) {
                    if(neighbor === rrtState.temp.newNode.parent) continue;

                    let newCost = rrtState.temp.newNode.cost +
                        Math.hypot(neighbor.x - rrtState.temp.newNode.x,
                                  neighbor.y - rrtState.temp.newNode.y);

                    if(newCost < neighbor.cost) {
                        // Rewire: change parent
                        if(neighbor.parent) {
                            neighbor.parent.children = neighbor.parent.children.filter(c => c !== neighbor);
                        }
                        neighbor.parent = rrtState.temp.newNode;
                        neighbor.cost = newCost;
                        rrtState.temp.newNode.children.push(neighbor);
                        rrtState.temp.rewiredNodes.push(neighbor);

                        // Propagate cost update to descendants
                        updateDescendantCosts(neighbor);
                    }
                }
            }

            highlightStep('rrt', 9);

            if(Math.hypot(rrtState.temp.newNode.x - GOAL_POS.x, rrtState.temp.newNode.y - GOAL_POS.y) < GOAL_THRESHOLD) {
                rrtState.currentState = 6;
                reconstructRRTPath();
                highlightStep('rrt', 6);
            } else {
                rrtState.currentState = 1;
            }
            return;
        }
    }

    function updateDescendantCosts(node) {
        for(let child of node.children) {
            child.cost = node.cost + Math.hypot(child.x - node.x, child.y - node.y);
            updateDescendantCosts(child);
        }
    }

    function reconstructRRTPath() {
        rrtState.path = [];
        let goalNode = null;
        let minDist = Infinity;

        for(let n of rrtState.nodes) {
            let d = Math.hypot(n.x - GOAL_POS.x, n.y - GOAL_POS.y);
            if(d < GOAL_THRESHOLD && d < minDist) {
                minDist = d;
                goalNode = n;
            }
        }

        if(goalNode) {
            let curr = goalNode;
            while(curr) {
                rrtState.path.unshift(curr);
                curr = curr.parent;
            }
            document.getElementById('cost-count').textContent = goalNode.cost.toFixed(2);
        }
    }

    function advancePRM() {
        if(rrtState.currentState === 5) return;

        if(rrtState.currentState === 0) {
            // Phase 1: Sample random nodes (avoiding obstacles)
            for(let i = 0; i < 10; i++) {
                if(rrtState.nodes.length >= rrtState.prmSamples) break;
                let x, y, attempts = 0;
                do {
                    x = Math.random() * SIZE;
                    y = Math.random() * SIZE;
                    attempts++;
                } while(isInsideObstacle(x, y) && attempts < 50);

                if(!isInsideObstacle(x, y)) {
                    rrtState.nodes.push(new Node(x, y));
                }
            }
            highlightStep('prm', 1);
            if(rrtState.nodes.length >= rrtState.prmSamples) rrtState.currentState = 2;

        } else if(rrtState.currentState === 2) {
            // Phase 2: Connect neighbors (build roadmap edges)
            rrtState.nodes.forEach(n => {
                rrtState.nodes.forEach(m => {
                    if(n !== m && Math.hypot(n.x - m.x, n.y - m.y) < 100 && !checkCollision(n, m)) {
                        if(!n.neighbors.includes(m)) n.neighbors.push(m);
                        if(!m.neighbors.includes(n)) m.neighbors.push(n); // Bidirectional
                    }
                });
            });
            rrtState.currentState = 3;
            highlightStep('prm', 2);

        } else if(rrtState.currentState === 3) {
            // Phase 3: Add start and goal, connect to roadmap
            let s = new Node(START_POS.x, START_POS.y);
            let g = new Node(GOAL_POS.x, GOAL_POS.y);
            s.isStart = true;
            g.isGoal = true;
            rrtState.nodes.push(s, g);

            // Connect start and goal to nearby roadmap nodes
            rrtState.nodes.forEach(m => {
                if(m !== s && m !== g) {
                    if(Math.hypot(s.x - m.x, s.y - m.y) < 150 && !checkCollision(s, m)) {
                        s.neighbors.push(m);
                        m.neighbors.push(s);
                    }
                    if(Math.hypot(g.x - m.x, g.y - m.y) < 150 && !checkCollision(g, m)) {
                        g.neighbors.push(m);
                        m.neighbors.push(g);
                    }
                }
            });

            rrtState.currentState = 4;
            highlightStep('prm', 3);

        } else if(rrtState.currentState === 4) {
            // Phase 4: Find path using Dijkstra on the roadmap
            const startNode = rrtState.nodes.find(n => n.isStart);
            const goalNode = rrtState.nodes.find(n => n.isGoal);

            if(startNode && goalNode) {
                rrtState.path = findPathDijkstra(startNode, goalNode);
                if(rrtState.path.length > 1) {
                    let cost = 0;
                    for(let i = 1; i < rrtState.path.length; i++) {
                        cost += Math.hypot(rrtState.path[i].x - rrtState.path[i-1].x,
                                          rrtState.path[i].y - rrtState.path[i-1].y);
                    }
                    document.getElementById('cost-count').textContent = cost.toFixed(2);
                }
            }

            rrtState.currentState = 5;
            highlightStep('prm', 5);
        }
        document.getElementById('node-count').textContent = rrtState.nodes.length;
    }

    function findPathDijkstra(start, goal) {
        // Dijkstra's algorithm on the PRM roadmap
        const dist = new Map();
        const prev = new Map();
        const visited = new Set();
        const queue = [];

        rrtState.nodes.forEach(n => dist.set(n, Infinity));
        dist.set(start, 0);
        queue.push(start);

        while(queue.length > 0) {
            // Find node with minimum distance
            queue.sort((a, b) => dist.get(a) - dist.get(b));
            const current = queue.shift();

            if(visited.has(current)) continue;
            visited.add(current);

            if(current === goal) break;

            for(let neighbor of current.neighbors) {
                if(visited.has(neighbor)) continue;

                const d = Math.hypot(neighbor.x - current.x, neighbor.y - current.y);
                const newDist = dist.get(current) + d;

                if(newDist < dist.get(neighbor)) {
                    dist.set(neighbor, newDist);
                    prev.set(neighbor, current);
                    queue.push(neighbor);
                }
            }
        }

        // Reconstruct path
        const path = [];
        let curr = goal;
        while(curr) {
            path.unshift(curr);
            curr = prev.get(curr);
        }

        // Return path only if it starts at start node
        if(path.length > 0 && path[0] === start) {
            return path;
        }
        return []; // No path found
    }

    function drawRrtScene() {
        rrtCtx.clearRect(0,0,SIZE,SIZE);

        // Draw obstacles
        rrtCtx.fillStyle = "#374151";
        obstacles.forEach(o => { rrtCtx.beginPath(); rrtCtx.arc(o.x, o.y, o.r, 0, Math.PI*2); rrtCtx.fill(); });

        // Draw tree edges
        rrtCtx.strokeStyle = "#86efac";
        rrtCtx.lineWidth = 1;
        rrtCtx.beginPath();
        rrtState.nodes.forEach(n => {
            if(n.parent) { rrtCtx.moveTo(n.parent.x, n.parent.y); rrtCtx.lineTo(n.x, n.y); }
            n.neighbors.forEach(m => { rrtCtx.moveTo(n.x, n.y); rrtCtx.lineTo(m.x, m.y); });
        });
        rrtCtx.stroke();

        // Draw RRT*/RRG specific visualizations
        if(rrtState.mode === 'RRT_STAR' || rrtState.mode === 'RRG') {
            // Draw neighbor search radius
            if(rrtState.temp.newNode && rrtState.currentState >= 8) {
                rrtCtx.beginPath();
                rrtCtx.arc(rrtState.temp.newNode.x, rrtState.temp.newNode.y, 60, 0, Math.PI*2);
                rrtCtx.strokeStyle = rrtState.mode === 'RRG' ? "rgba(16, 185, 129, 0.3)" : "rgba(147, 51, 234, 0.3)";
                rrtCtx.lineWidth = 2;
                rrtCtx.stroke();

                // Highlight neighbors
                const neighborColor = rrtState.mode === 'RRG' ? 'rgba(16, 185, 129, 0.6)' : 'rgba(147, 51, 234, 0.6)';
                rrtState.temp.nearNodes.forEach(n => {
                    drawCirc(rrtCtx, n.x, n.y, 5, neighborColor);
                });
            }

            // RRT*: Highlight rewired connections
            if(rrtState.mode === 'RRT_STAR' && rrtState.temp.rewiredNodes && rrtState.temp.rewiredNodes.length > 0) {
                rrtCtx.strokeStyle = "#f59e0b";
                rrtCtx.lineWidth = 2;
                rrtState.temp.rewiredNodes.forEach(n => {
                    if(n.parent) {
                        rrtCtx.beginPath();
                        rrtCtx.moveTo(n.parent.x, n.parent.y);
                        rrtCtx.lineTo(n.x, n.y);
                        rrtCtx.stroke();
                    }
                    drawCirc(rrtCtx, n.x, n.y, 5, '#f59e0b');
                });
            }

            // RRG: Draw all graph edges in different color
            if(rrtState.mode === 'RRG') {
                rrtCtx.strokeStyle = "rgba(16, 185, 129, 0.4)";
                rrtCtx.lineWidth = 1;
                rrtState.nodes.forEach(n => {
                    n.neighbors.forEach(m => {
                        rrtCtx.beginPath();
                        rrtCtx.moveTo(n.x, n.y);
                        rrtCtx.lineTo(m.x, m.y);
                        rrtCtx.stroke();
                    });
                });
            }
        }

        // Draw path if found
        if(rrtState.path.length > 1) {
            rrtCtx.beginPath();
            rrtCtx.moveTo(rrtState.path[0].x, rrtState.path[0].y);
            for(let i=1; i<rrtState.path.length; i++) {
                rrtCtx.lineTo(rrtState.path[i].x, rrtState.path[i].y);
            }
            rrtCtx.strokeStyle = "#3b82f6";
            rrtCtx.lineWidth = 3;
            rrtCtx.stroke();
        }

        // Draw nodes
        rrtState.nodes.forEach(n => {
            drawCirc(rrtCtx, n.x, n.y, 2, '#22c55e');
        });

        // Draw start and goal
        drawCirc(rrtCtx, START_POS.x, START_POS.y, 10, 'green');
        drawCirc(rrtCtx, GOAL_POS.x, GOAL_POS.y, 10, 'red');

        // Draw goal threshold
        rrtCtx.beginPath();
        rrtCtx.arc(GOAL_POS.x, GOAL_POS.y, GOAL_THRESHOLD, 0, Math.PI*2);
        rrtCtx.strokeStyle = "rgba(239, 68, 68, 0.3)";
        rrtCtx.lineWidth = 2;
        rrtCtx.stroke();

        // Draw current sample point
        if(rrtState.temp.randPoint) {
            drawCirc(rrtCtx, rrtState.temp.randPoint.x, rrtState.temp.randPoint.y, 4, 'orange');
            // Draw line from nearest to sample
            if(rrtState.temp.nearest) {
                rrtCtx.beginPath();
                rrtCtx.moveTo(rrtState.temp.nearest.x, rrtState.temp.nearest.y);
                rrtCtx.lineTo(rrtState.temp.randPoint.x, rrtState.temp.randPoint.y);
                rrtCtx.strokeStyle = "rgba(255, 165, 0, 0.4)";
                rrtCtx.lineWidth = 1;
                rrtCtx.setLineDash([5, 5]);
                rrtCtx.stroke();
                rrtCtx.setLineDash([]);
            }
        }

        // Draw new node being added
        if(rrtState.temp.newNode && rrtState.currentState >= 4) {
            drawCirc(rrtCtx, rrtState.temp.newNode.x, rrtState.temp.newNode.y, 5, '#f97316');
        }
    }

    function switchRrtTab(algo) {
        if(algo !== 'EDU') rrtState.algo = algo;

        document.getElementById('tab-RRT').classList.toggle('active', algo === 'RRT');
        document.getElementById('tab-PRM').classList.toggle('active', algo === 'PRM');
        document.getElementById('tab-RRT-EDU').classList.toggle('active', algo === 'EDU');

        document.getElementById('section-RRT').classList.toggle('active', algo === 'RRT');
        document.getElementById('section-PRM').classList.toggle('active', algo === 'PRM');
        document.getElementById('section-RRT-EDU').classList.toggle('active', algo === 'EDU');

        document.getElementById('rrt-toggle-group').style.display = (algo === 'RRT') ? 'flex' : 'none';
        document.getElementById('prm-slider-group').style.display = (algo === 'PRM') ? 'flex' : 'none';

        if(algo !== 'EDU') resetRrt();
    }
    
    function setRRTMode(mode) {
        rrtState.mode = mode;

        // Update buttons
        const modes = ['RRT', 'RRT_STAR', 'RRG'];
        const btnIds = ['btn-rrt-mode', 'btn-rrtstar-mode', 'btn-rrg-mode'];
        btnIds.forEach((id, i) => {
            document.getElementById(id).className = modes[i] === mode
                ? "px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
                : "px-3 py-1 text-xs rounded text-gray-600";
        });

        // Update badge
        const badgeText = mode === 'RRT_STAR' ? 'RRT*' : mode;
        document.getElementById('rrt-mode-badge').textContent = badgeText;
        document.getElementById('rrt-mode-badge').className = (mode === 'RRT_STAR' || mode === 'RRG')
            ? "text-xs font-bold px-2 py-1 rounded bg-purple-100 text-purple-800"
            : "text-xs font-bold px-2 py-1 rounded bg-gray-200";

        // Show RRT* steps for both RRT* and RRG
        document.getElementById('rrt-steps-container').classList.toggle('rrt-star-active', mode === 'RRT_STAR' || mode === 'RRG');

        resetRrt();
    }
    
    function updatePrmSamples(val) {
        rrtState.prmSamples = parseInt(val);
        document.getElementById('prmSampleVal').textContent = val;
        resetRrt();
    }

    function highlightStep(prefix, step) {
        document.querySelectorAll(`#section-${prefix.toUpperCase()} .step-item`).forEach(e => e.classList.remove('active'));
        let el = document.getElementById(`step-${prefix}-${step}`);
        if(el) el.classList.add('active');
    }


    // ==========================================
    // PART 2: TSP / TSPN / SOM LOGIC
    // ==========================================
    const tspCanvas = document.getElementById('tspCanvas');
    const tspCtx = tspCanvas.getContext('2d');

    let tspState = {
        mode: 'TSP', // TSP or TSPN
        dubins: false,
        targets: [],
        neurons: [], 
        learningRate: 0.1,
        influence: 0.5,
        initialized: false
    };

    let currentTspTab = 'CTRL';

    // Dubins Demo State
    const dubinsDemo = {
        start: { x: 150, y: 250, heading: 0 },
        goal: { x: 350, y: 250, heading: Math.PI },
        radius: 50,
        dragging: null, // 'start' or 'goal' when dragging
        dragStart: null // starting position for heading calculation
    };

    function switchTspTab(tab) {
        currentTspTab = tab;
        document.getElementById('tab-TSP-CTRL').classList.toggle('active', tab === 'CTRL');
        document.getElementById('tab-TSP-DUBINS').classList.toggle('active', tab === 'DUBINS');
        document.getElementById('tab-TSP-EDU').classList.toggle('active', tab === 'EDU');
        document.getElementById('section-TSP-CTRL').classList.toggle('active', tab === 'CTRL');
        document.getElementById('section-TSP-DUBINS').classList.toggle('active', tab === 'DUBINS');
        document.getElementById('section-TSP-EDU').classList.toggle('active', tab === 'EDU');

        if(tab === 'DUBINS') {
            drawDubinsDemo();
        } else {
            drawTspScene();
        }
    }

    function updateDubinsRadius(val) {
        dubinsDemo.radius = parseInt(val);
        document.getElementById('dubins-radius-val').textContent = val;
        if(currentTspTab === 'DUBINS') drawDubinsDemo();
    }

    function resetDubinsDemo() {
        dubinsDemo.start = { x: 150, y: 250, heading: 0 };
        dubinsDemo.goal = { x: 350, y: 250, heading: Math.PI };
        dubinsDemo.radius = 50;
        document.getElementById('dubins-radius-slider').value = 50;
        document.getElementById('dubins-radius-val').textContent = '50';
        drawDubinsDemo();
    }

    function setTspMode(m) {
        tspState.mode = m;
        document.getElementById('btn-mode-tsp').className = m === 'TSP' ? "px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600" : "px-3 py-1 text-xs rounded text-gray-600";
        document.getElementById('btn-mode-tspn').className = m === 'TSPN' ? "px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600" : "px-3 py-1 text-xs rounded text-gray-600";
        resetTsp();
    }

    function setDubins(d) {
        tspState.dubins = d;
        document.getElementById('btn-dubins-off').className = !d ? "px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600" : "px-3 py-1 text-xs rounded text-gray-600";
        document.getElementById('btn-dubins-on').className = d ? "px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600" : "px-3 py-1 text-xs rounded text-gray-600";
        resetTsp();
    }

    function initNeurons() {
        tspState.neurons = [];
        const num = Math.max(tspState.targets.length * 2, 20); 
        const cx = SIZE/2, cy = SIZE/2;
        for(let i=0; i<num; i++) {
            let angle = (i / num) * Math.PI * 2;
            tspState.neurons.push({
                x: cx + 50 * Math.cos(angle), 
                y: cy + 50 * Math.sin(angle)
            });
        }
        tspState.learningRate = 0.5;
        tspState.influence = num * 0.1;
        tspState.initialized = true;
    }

    function randomizeTspMap() {
        tspState.targets = [];
        for(let i=0; i<8; i++) {
            tspState.targets.push({
                x: Math.random() * 400 + 50,
                y: Math.random() * 400 + 50,
                r: 20 + Math.random() * 20, 
                heading: Math.random() * Math.PI * 2 
            });
        }
        resetTspLogicOnly();
    }

    tspCanvas.addEventListener('mousedown', e => {
        if(currentView !== VIEWS.TSP) return;
        const rect = tspCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (tspCanvas.width / rect.width);
        const y = (e.clientY - rect.top) * (tspCanvas.height / rect.height);

        // Dubins Demo mode
        if(currentTspTab === 'DUBINS') {
            if(e.button === 0) { // Left click - start
                dubinsDemo.start.x = x;
                dubinsDemo.start.y = y;
                dubinsDemo.dragging = 'start';
            } else if(e.button === 2) { // Right click - goal
                dubinsDemo.goal.x = x;
                dubinsDemo.goal.y = y;
                dubinsDemo.dragging = 'goal';
            }
            dubinsDemo.dragStart = { x, y };
            drawDubinsDemo();
            return;
        }

        // Normal TSP mode
        tspState.targets.push({
            x: x, y: y, r: 25, heading: Math.random() * Math.PI * 2
        });
        resetTspLogicOnly();
        drawTspScene();
    });

    tspCanvas.addEventListener('mousemove', e => {
        if(currentView !== VIEWS.TSP || currentTspTab !== 'DUBINS') return;
        if(!dubinsDemo.dragging) return;

        const rect = tspCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (tspCanvas.width / rect.width);
        const y = (e.clientY - rect.top) * (tspCanvas.height / rect.height);

        const config = dubinsDemo.dragging === 'start' ? dubinsDemo.start : dubinsDemo.goal;
        config.heading = Math.atan2(y - config.y, x - config.x);
        drawDubinsDemo();
    });

    tspCanvas.addEventListener('mouseup', e => {
        if(currentView !== VIEWS.TSP || currentTspTab !== 'DUBINS') return;
        dubinsDemo.dragging = null;
    });

    tspCanvas.addEventListener('contextmenu', e => {
        if(currentView === VIEWS.TSP && currentTspTab === 'DUBINS') {
            e.preventDefault();
        }
    });

    tspCanvas.addEventListener('mouseleave', e => {
        if(currentView === VIEWS.TSP && currentTspTab === 'DUBINS') {
            dubinsDemo.dragging = null;
        }
    });

    function resetTsp() {
        stopAuto();
        tspState.targets = [];
        resetTspLogicOnly();
        randomizeTspMap(); 
    }

    function resetTspLogicOnly() {
        tspState.neurons = [];
        tspState.initialized = false;
        tspState.learningRate = 0.5;
        document.getElementById('tsp-status').textContent = "Ready. Click 'Play' to solve.";
        drawTspScene();
    }

    function advanceTSP() {
        if(tspState.targets.length < 2) return;
        if(!tspState.initialized) initNeurons();

        const targetIdx = Math.floor(Math.random() * tspState.targets.length);
        const T = tspState.targets[targetIdx];

        let bmu = null;
        let minDist = Infinity;
        
        tspState.neurons.forEach((n, idx) => {
            let distCenter = Math.hypot(n.x - T.x, n.y - T.y);
            let dist = distCenter;
            if (tspState.mode === 'TSPN') dist = Math.max(0, distCenter - T.r); 
            if(dist < minDist) { minDist = dist; bmu = idx; }
        });

        tspState.neurons.forEach((n, idx) => {
            let dRing = Math.abs(idx - bmu);
            dRing = Math.min(dRing, tspState.neurons.length - dRing); 
            let h = Math.exp(- (dRing * dRing) / (2 * tspState.influence * tspState.influence));
            if (h > 0.001) {
                let pullX = T.x; 
                let pullY = T.y;
                n.x += h * tspState.learningRate * (pullX - n.x);
                n.y += h * tspState.learningRate * (pullY - n.y);
            }
        });

        tspState.learningRate *= 0.99;
        tspState.influence *= 0.99;
        if(tspState.learningRate < 0.001) stopAuto();

        document.getElementById('som-neurons').textContent = tspState.neurons.length;
        document.getElementById('tsp-cost').textContent = calculateTourLength().toFixed(1);
        document.getElementById('tsp-status').textContent = `Learning... LR: ${tspState.learningRate.toFixed(3)}`;
    }

    function stepTspOnce() {
        stopAuto();
        advanceTSP();
        drawTspScene();
    }

    function drawTspScene() {
        tspCtx.clearRect(0, 0, SIZE, SIZE);
        tspState.targets.forEach((t, i) => {
            tspCtx.beginPath();
            if(tspState.mode === 'TSPN') {
                tspCtx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
                tspCtx.fillStyle = "rgba(59, 130, 246, 0.2)"; 
                tspCtx.fill();
                tspCtx.strokeStyle = "#3b82f6";
                tspCtx.stroke();
            } else {
                tspCtx.arc(t.x, t.y, 5, 0, Math.PI * 2);
                tspCtx.fillStyle = "#3b82f6";
                tspCtx.fill();
            }
            tspCtx.closePath();

            if(tspState.dubins) {
                tspCtx.beginPath();
                tspCtx.moveTo(t.x, t.y);
                tspCtx.lineTo(t.x + 20*Math.cos(t.heading), t.y + 20*Math.sin(t.heading));
                tspCtx.strokeStyle = "red";
                tspCtx.lineWidth = 2;
                tspCtx.stroke();
                tspCtx.beginPath();
                tspCtx.arc(t.x + 20*Math.cos(t.heading), t.y + 20*Math.sin(t.heading), 2, 0, Math.PI*2);
                tspCtx.fillStyle = "red";
                tspCtx.fill();
            }
        });

        if(tspState.neurons.length === 0) return;

        tspCtx.beginPath();
        if(tspState.neurons.length > 0) tspCtx.moveTo(tspState.neurons[0].x, tspState.neurons[0].y);
        for(let i=1; i<tspState.neurons.length; i++) {
            let p1 = tspState.neurons[i-1];
            let p2 = tspState.neurons[i];
            if(tspState.dubins) drawDubinsCurveApprox(tspCtx, p1, p2);
            else tspCtx.lineTo(p2.x, p2.y);
        }
        let last = tspState.neurons[tspState.neurons.length-1];
        let first = tspState.neurons[0];
        if(tspState.dubins) drawDubinsCurveApprox(tspCtx, last, first);
        else tspCtx.lineTo(first.x, first.y);

        tspCtx.strokeStyle = tspState.dubins ? "#10b981" : "#f59e0b"; 
        tspCtx.lineWidth = 2;
        tspCtx.stroke();

        tspState.neurons.forEach(n => {
            tspCtx.beginPath(); tspCtx.arc(n.x, n.y, 2, 0, Math.PI*2); tspCtx.fillStyle = "orange"; tspCtx.fill();
        });
    }

    function drawDubinsCurveApprox(ctx, p1, p2, turnRadius = 25) {
        // Simulate a simple CSC (Curve-Straight-Curve) Dubins path
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        let dist = Math.hypot(dx, dy);

        if(dist < turnRadius * 2) {
            // Too close - just curve
            let mx = (p1.x + p2.x) / 2;
            let my = (p1.y + p2.y) / 2;
            let ox = -dy * 0.3;
            let oy = dx * 0.3;
            ctx.quadraticCurveTo(mx + ox, my + oy, p2.x, p2.y);
        } else {
            // CSC path approximation
            let angle = Math.atan2(dy, dx);
            let perpAngle = angle + Math.PI/2;

            // First curve (turn out)
            let c1x = p1.x + turnRadius * 0.4 * Math.cos(perpAngle);
            let c1y = p1.y + turnRadius * 0.4 * Math.sin(perpAngle);

            // Second curve (turn in)
            let c2x = p2.x + turnRadius * 0.4 * Math.cos(perpAngle);
            let c2y = p2.y + turnRadius * 0.4 * Math.sin(perpAngle);

            ctx.bezierCurveTo(c1x, c1y, c2x, c2y, p2.x, p2.y);
        }
    }

    // Calculate tour length for display
    function calculateTourLength() {
        if(tspState.neurons.length < 2) return 0;
        let len = 0;
        for(let i=0; i<tspState.neurons.length; i++) {
            let n1 = tspState.neurons[i];
            let n2 = tspState.neurons[(i+1) % tspState.neurons.length];
            len += Math.hypot(n2.x - n1.x, n2.y - n1.y);
        }
        return len;
    }

    // ============ DUBINS DEMO FUNCTIONS ============

    function drawDubinsDemo() {
        const ctx = tspCtx;
        const r = dubinsDemo.radius;
        const start = dubinsDemo.start;
        const goal = dubinsDemo.goal;

        ctx.clearRect(0, 0, SIZE, SIZE);

        // Background grid
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        for(let i = 0; i <= SIZE; i += 50) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, SIZE); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(SIZE, i); ctx.stroke();
        }

        // Calculate turning circle centers for start
        const startLeftCenter = {
            x: start.x + r * Math.cos(start.heading + Math.PI/2),
            y: start.y + r * Math.sin(start.heading + Math.PI/2)
        };
        const startRightCenter = {
            x: start.x + r * Math.cos(start.heading - Math.PI/2),
            y: start.y + r * Math.sin(start.heading - Math.PI/2)
        };

        // Calculate turning circle centers for goal
        const goalLeftCenter = {
            x: goal.x + r * Math.cos(goal.heading + Math.PI/2),
            y: goal.y + r * Math.sin(goal.heading + Math.PI/2)
        };
        const goalRightCenter = {
            x: goal.x + r * Math.cos(goal.heading - Math.PI/2),
            y: goal.y + r * Math.sin(goal.heading - Math.PI/2)
        };

        // Draw turning circles (dashed)
        ctx.setLineDash([5, 5]);

        // Start circles
        ctx.strokeStyle = '#86efac'; // green-300
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(startLeftCenter.x, startLeftCenter.y, r, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = '#93c5fd'; // blue-300
        ctx.beginPath(); ctx.arc(startRightCenter.x, startRightCenter.y, r, 0, Math.PI*2); ctx.stroke();

        // Goal circles
        ctx.strokeStyle = '#86efac';
        ctx.beginPath(); ctx.arc(goalLeftCenter.x, goalLeftCenter.y, r, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = '#93c5fd';
        ctx.beginPath(); ctx.arc(goalRightCenter.x, goalRightCenter.y, r, 0, Math.PI*2); ctx.stroke();

        ctx.setLineDash([]);

        // Compute and draw the best Dubins path
        const dubinsPath = computeBestDubinsPath(start, goal, r);
        drawDubinsPath(ctx, dubinsPath, r);

        // Draw start configuration
        ctx.fillStyle = '#22c55e'; // green
        ctx.beginPath(); ctx.arc(start.x, start.y, 10, 0, Math.PI*2); ctx.fill();
        // Heading arrow
        ctx.strokeStyle = '#15803d';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(start.x + 30*Math.cos(start.heading), start.y + 30*Math.sin(start.heading));
        ctx.stroke();
        // Arrow head
        drawArrowHead(ctx, start.x + 30*Math.cos(start.heading), start.y + 30*Math.sin(start.heading), start.heading, '#15803d');
        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('S', start.x, start.y + 4);

        // Draw goal configuration
        ctx.fillStyle = '#ef4444'; // red
        ctx.beginPath(); ctx.arc(goal.x, goal.y, 10, 0, Math.PI*2); ctx.fill();
        // Heading arrow
        ctx.strokeStyle = '#b91c1c';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(goal.x, goal.y);
        ctx.lineTo(goal.x + 30*Math.cos(goal.heading), goal.y + 30*Math.sin(goal.heading));
        ctx.stroke();
        drawArrowHead(ctx, goal.x + 30*Math.cos(goal.heading), goal.y + 30*Math.sin(goal.heading), goal.heading, '#b91c1c');
        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px sans-serif';
        ctx.fillText('G', goal.x, goal.y + 4);

        // Draw circle labels
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#22c55e';
        ctx.fillText('L', startLeftCenter.x, startLeftCenter.y - r - 5);
        ctx.fillStyle = '#3b82f6';
        ctx.fillText('R', startRightCenter.x, startRightCenter.y - r - 5);

        // Update path info display
        document.getElementById('dubins-path-type').textContent = dubinsPath.type;
        document.getElementById('dubins-path-length').textContent = dubinsPath.length.toFixed(1);
    }

    function drawArrowHead(ctx, x, y, angle, color) {
        const size = 8;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - size*Math.cos(angle - 0.4), y - size*Math.sin(angle - 0.4));
        ctx.lineTo(x - size*Math.cos(angle + 0.4), y - size*Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();
    }

    function normalizeAngle(a) {
        while(a > Math.PI) a -= 2*Math.PI;
        while(a < -Math.PI) a += 2*Math.PI;
        return a;
    }

    function computeBestDubinsPath(start, goal, r) {
        // Compute all 6 Dubins path types and return the shortest
        const paths = [
            computeLSL(start, goal, r),
            computeRSR(start, goal, r),
            computeLSR(start, goal, r),
            computeRSL(start, goal, r),
            computeLRL(start, goal, r),
            computeRLR(start, goal, r)
        ].filter(p => p !== null);

        if(paths.length === 0) {
            return { type: 'N/A', length: 0, segments: [] };
        }

        return paths.reduce((best, p) => p.length < best.length ? p : best);
    }

    function computeLSL(start, goal, r) {
        // Left turn from start, Straight, Left turn to goal
        const c1 = { x: start.x + r*Math.cos(start.heading + Math.PI/2), y: start.y + r*Math.sin(start.heading + Math.PI/2) };
        const c2 = { x: goal.x + r*Math.cos(goal.heading + Math.PI/2), y: goal.y + r*Math.sin(goal.heading + Math.PI/2) };

        const dx = c2.x - c1.x;
        const dy = c2.y - c1.y;
        const d = Math.hypot(dx, dy);

        const theta = Math.atan2(dy, dx);

        // Tangent points
        const t1 = { x: c1.x + r*Math.cos(theta - Math.PI/2), y: c1.y + r*Math.sin(theta - Math.PI/2) };
        const t2 = { x: c2.x + r*Math.cos(theta - Math.PI/2), y: c2.y + r*Math.sin(theta - Math.PI/2) };

        // Arc angles
        const startAngle1 = Math.atan2(start.y - c1.y, start.x - c1.x);
        const endAngle1 = Math.atan2(t1.y - c1.y, t1.x - c1.x);
        let arc1 = normalizeAngle(endAngle1 - startAngle1);
        if(arc1 < 0) arc1 += 2*Math.PI; // Left turn is counterclockwise

        const startAngle2 = Math.atan2(t2.y - c2.y, t2.x - c2.x);
        const endAngle2 = Math.atan2(goal.y - c2.y, goal.x - c2.x);
        let arc2 = normalizeAngle(endAngle2 - startAngle2);
        if(arc2 < 0) arc2 += 2*Math.PI;

        const length = r*arc1 + d + r*arc2;

        return {
            type: 'LSL',
            length: length,
            segments: [
                { type: 'arc', center: c1, startAngle: startAngle1, endAngle: endAngle1, ccw: true, r: r },
                { type: 'line', start: t1, end: t2 },
                { type: 'arc', center: c2, startAngle: startAngle2, endAngle: endAngle2, ccw: true, r: r }
            ]
        };
    }

    function computeRSR(start, goal, r) {
        // Right turn from start, Straight, Right turn to goal
        const c1 = { x: start.x + r*Math.cos(start.heading - Math.PI/2), y: start.y + r*Math.sin(start.heading - Math.PI/2) };
        const c2 = { x: goal.x + r*Math.cos(goal.heading - Math.PI/2), y: goal.y + r*Math.sin(goal.heading - Math.PI/2) };

        const dx = c2.x - c1.x;
        const dy = c2.y - c1.y;
        const d = Math.hypot(dx, dy);

        const theta = Math.atan2(dy, dx);

        // Tangent points
        const t1 = { x: c1.x + r*Math.cos(theta + Math.PI/2), y: c1.y + r*Math.sin(theta + Math.PI/2) };
        const t2 = { x: c2.x + r*Math.cos(theta + Math.PI/2), y: c2.y + r*Math.sin(theta + Math.PI/2) };

        // Arc angles
        const startAngle1 = Math.atan2(start.y - c1.y, start.x - c1.x);
        const endAngle1 = Math.atan2(t1.y - c1.y, t1.x - c1.x);
        let arc1 = normalizeAngle(startAngle1 - endAngle1);
        if(arc1 < 0) arc1 += 2*Math.PI;

        const startAngle2 = Math.atan2(t2.y - c2.y, t2.x - c2.x);
        const endAngle2 = Math.atan2(goal.y - c2.y, goal.x - c2.x);
        let arc2 = normalizeAngle(startAngle2 - endAngle2);
        if(arc2 < 0) arc2 += 2*Math.PI;

        const length = r*arc1 + d + r*arc2;

        return {
            type: 'RSR',
            length: length,
            segments: [
                { type: 'arc', center: c1, startAngle: startAngle1, endAngle: endAngle1, ccw: false, r: r },
                { type: 'line', start: t1, end: t2 },
                { type: 'arc', center: c2, startAngle: startAngle2, endAngle: endAngle2, ccw: false, r: r }
            ]
        };
    }

    function computeLSR(start, goal, r) {
        // Left turn from start, Straight, Right turn to goal
        const c1 = { x: start.x + r*Math.cos(start.heading + Math.PI/2), y: start.y + r*Math.sin(start.heading + Math.PI/2) };
        const c2 = { x: goal.x + r*Math.cos(goal.heading - Math.PI/2), y: goal.y + r*Math.sin(goal.heading - Math.PI/2) };

        const dx = c2.x - c1.x;
        const dy = c2.y - c1.y;
        const d = Math.hypot(dx, dy);

        if(d < 2*r) return null; // Tangent doesn't exist

        const theta = Math.atan2(dy, dx);
        const alpha = Math.acos(2*r / d);

        // Tangent points
        const t1 = { x: c1.x + r*Math.cos(theta + alpha), y: c1.y + r*Math.sin(theta + alpha) };
        const t2 = { x: c2.x + r*Math.cos(theta + alpha + Math.PI), y: c2.y + r*Math.sin(theta + alpha + Math.PI) };

        // Arc angles
        const startAngle1 = Math.atan2(start.y - c1.y, start.x - c1.x);
        const endAngle1 = Math.atan2(t1.y - c1.y, t1.x - c1.x);
        let arc1 = normalizeAngle(endAngle1 - startAngle1);
        if(arc1 < 0) arc1 += 2*Math.PI;

        const startAngle2 = Math.atan2(t2.y - c2.y, t2.x - c2.x);
        const endAngle2 = Math.atan2(goal.y - c2.y, goal.x - c2.x);
        let arc2 = normalizeAngle(startAngle2 - endAngle2);
        if(arc2 < 0) arc2 += 2*Math.PI;

        const straightLen = Math.hypot(t2.x - t1.x, t2.y - t1.y);
        const length = r*arc1 + straightLen + r*arc2;

        return {
            type: 'LSR',
            length: length,
            segments: [
                { type: 'arc', center: c1, startAngle: startAngle1, endAngle: endAngle1, ccw: true, r: r },
                { type: 'line', start: t1, end: t2 },
                { type: 'arc', center: c2, startAngle: startAngle2, endAngle: endAngle2, ccw: false, r: r }
            ]
        };
    }

    function computeRSL(start, goal, r) {
        // Right turn from start, Straight, Left turn to goal
        const c1 = { x: start.x + r*Math.cos(start.heading - Math.PI/2), y: start.y + r*Math.sin(start.heading - Math.PI/2) };
        const c2 = { x: goal.x + r*Math.cos(goal.heading + Math.PI/2), y: goal.y + r*Math.sin(goal.heading + Math.PI/2) };

        const dx = c2.x - c1.x;
        const dy = c2.y - c1.y;
        const d = Math.hypot(dx, dy);

        if(d < 2*r) return null;

        const theta = Math.atan2(dy, dx);
        const alpha = Math.acos(2*r / d);

        // Tangent points
        const t1 = { x: c1.x + r*Math.cos(theta - alpha), y: c1.y + r*Math.sin(theta - alpha) };
        const t2 = { x: c2.x + r*Math.cos(theta - alpha + Math.PI), y: c2.y + r*Math.sin(theta - alpha + Math.PI) };

        // Arc angles
        const startAngle1 = Math.atan2(start.y - c1.y, start.x - c1.x);
        const endAngle1 = Math.atan2(t1.y - c1.y, t1.x - c1.x);
        let arc1 = normalizeAngle(startAngle1 - endAngle1);
        if(arc1 < 0) arc1 += 2*Math.PI;

        const startAngle2 = Math.atan2(t2.y - c2.y, t2.x - c2.x);
        const endAngle2 = Math.atan2(goal.y - c2.y, goal.x - c2.x);
        let arc2 = normalizeAngle(endAngle2 - startAngle2);
        if(arc2 < 0) arc2 += 2*Math.PI;

        const straightLen = Math.hypot(t2.x - t1.x, t2.y - t1.y);
        const length = r*arc1 + straightLen + r*arc2;

        return {
            type: 'RSL',
            length: length,
            segments: [
                { type: 'arc', center: c1, startAngle: startAngle1, endAngle: endAngle1, ccw: false, r: r },
                { type: 'line', start: t1, end: t2 },
                { type: 'arc', center: c2, startAngle: startAngle2, endAngle: endAngle2, ccw: true, r: r }
            ]
        };
    }

    function computeLRL(start, goal, r) {
        // Left-Right-Left (CCC path)
        const c1 = { x: start.x + r*Math.cos(start.heading + Math.PI/2), y: start.y + r*Math.sin(start.heading + Math.PI/2) };
        const c3 = { x: goal.x + r*Math.cos(goal.heading + Math.PI/2), y: goal.y + r*Math.sin(goal.heading + Math.PI/2) };

        const dx = c3.x - c1.x;
        const dy = c3.y - c1.y;
        const d = Math.hypot(dx, dy);

        if(d > 4*r) return null; // Too far for CCC

        const theta = Math.atan2(dy, dx);
        const alpha = Math.acos(d / (4*r));

        // Middle circle center
        const c2 = {
            x: c1.x + 2*r*Math.cos(theta + alpha),
            y: c1.y + 2*r*Math.sin(theta + alpha)
        };

        // Tangent points
        const t1 = {
            x: (c1.x + c2.x) / 2,
            y: (c1.y + c2.y) / 2
        };
        const t2 = {
            x: (c2.x + c3.x) / 2,
            y: (c2.y + c3.y) / 2
        };

        // Arc calculations
        const startAngle1 = Math.atan2(start.y - c1.y, start.x - c1.x);
        const endAngle1 = Math.atan2(t1.y - c1.y, t1.x - c1.x);
        let arc1 = normalizeAngle(endAngle1 - startAngle1);
        if(arc1 < 0) arc1 += 2*Math.PI;

        const startAngle2 = Math.atan2(t1.y - c2.y, t1.x - c2.x);
        const endAngle2 = Math.atan2(t2.y - c2.y, t2.x - c2.x);
        let arc2 = normalizeAngle(startAngle2 - endAngle2);
        if(arc2 < 0) arc2 += 2*Math.PI;

        const startAngle3 = Math.atan2(t2.y - c3.y, t2.x - c3.x);
        const endAngle3 = Math.atan2(goal.y - c3.y, goal.x - c3.x);
        let arc3 = normalizeAngle(endAngle3 - startAngle3);
        if(arc3 < 0) arc3 += 2*Math.PI;

        const length = r*(arc1 + arc2 + arc3);

        return {
            type: 'LRL',
            length: length,
            segments: [
                { type: 'arc', center: c1, startAngle: startAngle1, endAngle: endAngle1, ccw: true, r: r },
                { type: 'arc', center: c2, startAngle: startAngle2, endAngle: endAngle2, ccw: false, r: r },
                { type: 'arc', center: c3, startAngle: startAngle3, endAngle: endAngle3, ccw: true, r: r }
            ]
        };
    }

    function computeRLR(start, goal, r) {
        // Right-Left-Right (CCC path)
        const c1 = { x: start.x + r*Math.cos(start.heading - Math.PI/2), y: start.y + r*Math.sin(start.heading - Math.PI/2) };
        const c3 = { x: goal.x + r*Math.cos(goal.heading - Math.PI/2), y: goal.y + r*Math.sin(goal.heading - Math.PI/2) };

        const dx = c3.x - c1.x;
        const dy = c3.y - c1.y;
        const d = Math.hypot(dx, dy);

        if(d > 4*r) return null;

        const theta = Math.atan2(dy, dx);
        const alpha = Math.acos(d / (4*r));

        const c2 = {
            x: c1.x + 2*r*Math.cos(theta - alpha),
            y: c1.y + 2*r*Math.sin(theta - alpha)
        };

        const t1 = {
            x: (c1.x + c2.x) / 2,
            y: (c1.y + c2.y) / 2
        };
        const t2 = {
            x: (c2.x + c3.x) / 2,
            y: (c2.y + c3.y) / 2
        };

        const startAngle1 = Math.atan2(start.y - c1.y, start.x - c1.x);
        const endAngle1 = Math.atan2(t1.y - c1.y, t1.x - c1.x);
        let arc1 = normalizeAngle(startAngle1 - endAngle1);
        if(arc1 < 0) arc1 += 2*Math.PI;

        const startAngle2 = Math.atan2(t1.y - c2.y, t1.x - c2.x);
        const endAngle2 = Math.atan2(t2.y - c2.y, t2.x - c2.x);
        let arc2 = normalizeAngle(endAngle2 - startAngle2);
        if(arc2 < 0) arc2 += 2*Math.PI;

        const startAngle3 = Math.atan2(t2.y - c3.y, t2.x - c3.x);
        const endAngle3 = Math.atan2(goal.y - c3.y, goal.x - c3.x);
        let arc3 = normalizeAngle(startAngle3 - endAngle3);
        if(arc3 < 0) arc3 += 2*Math.PI;

        const length = r*(arc1 + arc2 + arc3);

        return {
            type: 'RLR',
            length: length,
            segments: [
                { type: 'arc', center: c1, startAngle: startAngle1, endAngle: endAngle1, ccw: false, r: r },
                { type: 'arc', center: c2, startAngle: startAngle2, endAngle: endAngle2, ccw: true, r: r },
                { type: 'arc', center: c3, startAngle: startAngle3, endAngle: endAngle3, ccw: false, r: r }
            ]
        };
    }

    function drawDubinsPath(ctx, path, r) {
        if(!path.segments || path.segments.length === 0) return;

        ctx.lineWidth = 4;

        path.segments.forEach((seg, i) => {
            if(seg.type === 'arc') {
                ctx.strokeStyle = '#f97316'; // orange for arcs
                ctx.beginPath();
                if(seg.ccw) {
                    ctx.arc(seg.center.x, seg.center.y, seg.r, seg.startAngle, seg.endAngle, false);
                } else {
                    ctx.arc(seg.center.x, seg.center.y, seg.r, seg.startAngle, seg.endAngle, true);
                }
                ctx.stroke();
            } else if(seg.type === 'line') {
                ctx.strokeStyle = '#a855f7'; // purple for straight
                ctx.beginPath();
                ctx.moveTo(seg.start.x, seg.start.y);
                ctx.lineTo(seg.end.x, seg.end.y);
                ctx.stroke();
            }
        });
    }
    
    function drawCirc(ctx, x, y, r, c) {
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle=c; ctx.fill();
    }


    // ==========================================
    // PART 3: GRID / A* / THETA* / D* LITE
    // ==========================================
    const gridCanvas = document.getElementById('gridCanvas');
    const gridCtx = gridCanvas.getContext('2d');
    
    // Grid Config
    const GRID_DIM = 25; 
    const CELL_SIZE = SIZE / GRID_DIM;
    
    let gridState = {
        algo: 'ASTAR', // 'ASTAR', 'THETA', 'DLITE'
        grid: [],
        start: {x: 2, y: 22},
        goal: {x: 22, y: 2},
        openSet: [],
        closedSet: [],
        path: [],
        current: null,
        finished: false,
        // D* Lite specific
        rhs: [], // 2D array
        g: [], // 2D array
        dLiteQueue: [], // Priority Queue for D*
        stepState: 0, // For visual stepping
        cspaceMode: false, // C-space visualization mode
        dtransMode: false, // Distance transform visualization mode
        visGraphMode: false // Visibility graph / Voronoi mode
    };

    function switchGridTab(tab) {
        document.getElementById('tab-GRID-CTRL').classList.toggle('active', tab === 'CTRL');
        document.getElementById('tab-GRID-CSPACE').classList.toggle('active', tab === 'CSPACE');
        document.getElementById('tab-GRID-DTRANS').classList.toggle('active', tab === 'DTRANS');
        document.getElementById('tab-GRID-VISGRAPH').classList.toggle('active', tab === 'VISGRAPH');
        document.getElementById('tab-GRID-EDU').classList.toggle('active', tab === 'EDU');
        document.getElementById('section-GRID-CTRL').classList.toggle('active', tab === 'CTRL');
        document.getElementById('section-GRID-CSPACE').classList.toggle('active', tab === 'CSPACE');
        document.getElementById('section-GRID-DTRANS').classList.toggle('active', tab === 'DTRANS');
        document.getElementById('section-GRID-VISGRAPH').classList.toggle('active', tab === 'VISGRAPH');
        document.getElementById('section-GRID-EDU').classList.toggle('active', tab === 'EDU');

        // Switch visualization mode
        gridState.cspaceMode = (tab === 'CSPACE');
        gridState.dtransMode = (tab === 'DTRANS');
        gridState.visGraphMode = (tab === 'VISGRAPH');

        if(tab === 'DTRANS') {
            computeDistanceTransform();
        }
        if(tab === 'VISGRAPH') {
            buildVisibilityGraph();
        }
        drawGridScene();
    }

    // C-Space specific state and functions
    let cspaceState = {
        robotRadius: 2,
        view: 'WORKSPACE', // WORKSPACE, CSPACE, or BOTH
        robotPos: { x: 5, y: 20 }
    };

    function updateRobotRadius(val) {
        cspaceState.robotRadius = parseInt(val);
        document.getElementById('robot-radius-val').textContent = val;
        drawGridScene();
    }

    function setCSpaceView(view) {
        cspaceState.view = view;
        ['WORKSPACE', 'CSPACE', 'BOTH'].forEach(v => {
            document.getElementById(`btn-view-${v.toLowerCase()}`).className =
                v === view ? "px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
                          : "px-2 py-1 text-xs rounded text-gray-600";
        });
        drawGridScene();
    }

    // Distance Transform state and functions
    let dtransState = {
        distances: [],  // 2D array of distances
        maxDist: 0,
        safestPoint: {x: 0, y: 0},
        view: 'DISTANCE', // DISTANCE or GRADIENT
        animating: false,
        animationStep: 0
    };

    function computeDistanceTransform() {
        // Initialize distances: 0 for obstacles, Infinity for free
        dtransState.distances = [];
        for(let y = 0; y < GRID_DIM; y++) {
            let row = [];
            for(let x = 0; x < GRID_DIM; x++) {
                row.push(gridState.grid[y][x] === 1 ? 0 : Infinity);
            }
            dtransState.distances.push(row);
        }

        // BFS from all obstacle cells (Brushfire algorithm)
        let queue = [];
        for(let y = 0; y < GRID_DIM; y++) {
            for(let x = 0; x < GRID_DIM; x++) {
                if(gridState.grid[y][x] === 1) {
                    queue.push({x, y, dist: 0});
                }
            }
        }

        const dirs = [{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:0,dy:1},
                      {dx:-1,dy:-1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:1,dy:1}];

        while(queue.length > 0) {
            const {x, y, dist} = queue.shift();
            for(let d of dirs) {
                const nx = x + d.dx;
                const ny = y + d.dy;
                if(nx >= 0 && nx < GRID_DIM && ny >= 0 && ny < GRID_DIM) {
                    const newDist = dist + (d.dx !== 0 && d.dy !== 0 ? 1.414 : 1);
                    if(newDist < dtransState.distances[ny][nx]) {
                        dtransState.distances[ny][nx] = newDist;
                        queue.push({x: nx, y: ny, dist: newDist});
                    }
                }
            }
        }

        // Find max distance and safest point
        dtransState.maxDist = 0;
        dtransState.safestPoint = {x: 0, y: 0};
        for(let y = 0; y < GRID_DIM; y++) {
            for(let x = 0; x < GRID_DIM; x++) {
                if(dtransState.distances[y][x] > dtransState.maxDist && dtransState.distances[y][x] !== Infinity) {
                    dtransState.maxDist = dtransState.distances[y][x];
                    dtransState.safestPoint = {x, y};
                }
            }
        }

        // Update UI
        document.getElementById('dtrans-max').textContent = dtransState.maxDist.toFixed(1);
        document.getElementById('dtrans-safest').textContent = `(${dtransState.safestPoint.x}, ${dtransState.safestPoint.y})`;
    }

    function setDTransView(view) {
        dtransState.view = view;
        document.getElementById('btn-dtrans-dist').className =
            view === 'DISTANCE' ? "px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
                                : "px-2 py-1 text-xs rounded text-gray-600";
        document.getElementById('btn-dtrans-grad').className =
            view === 'GRADIENT' ? "px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
                                : "px-2 py-1 text-xs rounded text-gray-600";
        drawGridScene();
    }

    function animateBrushfire() {
        if(dtransState.animating) {
            dtransState.animating = false;
            document.getElementById('btn-brushfire').textContent = '▶ Animate Brushfire';
            return;
        }

        dtransState.animating = true;
        dtransState.animationStep = 0;
        document.getElementById('btn-brushfire').textContent = '⏹ Stop';

        // Reset distances for animation
        let tempDistances = [];
        for(let y = 0; y < GRID_DIM; y++) {
            let row = [];
            for(let x = 0; x < GRID_DIM; x++) {
                row.push(gridState.grid[y][x] === 1 ? 0 : -1); // -1 = not yet reached
            }
            tempDistances.push(row);
        }

        let queue = [];
        for(let y = 0; y < GRID_DIM; y++) {
            for(let x = 0; x < GRID_DIM; x++) {
                if(gridState.grid[y][x] === 1) queue.push({x, y, dist: 0});
            }
        }

        const dirs = [{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:0,dy:1},
                      {dx:-1,dy:-1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:1,dy:1}];

        function animStep() {
            if(!dtransState.animating || queue.length === 0) {
                dtransState.animating = false;
                document.getElementById('btn-brushfire').textContent = '▶ Animate Brushfire';
                computeDistanceTransform(); // Ensure final state is correct
                drawGridScene();
                return;
            }

            // Process one layer (all cells at current distance)
            let currentDist = queue[0].dist;
            let processed = [];
            while(queue.length > 0 && queue[0].dist === currentDist) {
                processed.push(queue.shift());
            }

            for(let cell of processed) {
                for(let d of dirs) {
                    const nx = cell.x + d.dx;
                    const ny = cell.y + d.dy;
                    if(nx >= 0 && nx < GRID_DIM && ny >= 0 && ny < GRID_DIM && tempDistances[ny][nx] === -1) {
                        const newDist = cell.dist + (d.dx !== 0 && d.dy !== 0 ? 1.414 : 1);
                        tempDistances[ny][nx] = newDist;
                        queue.push({x: nx, y: ny, dist: newDist});
                    }
                }
            }

            // Draw current state
            dtransState.distances = tempDistances.map(row => row.map(v => v === -1 ? Infinity : v));
            dtransState.maxDist = Math.max(...tempDistances.flat().filter(v => v >= 0));
            drawGridScene();

            setTimeout(animStep, getIntervalDelay());
        }

        animStep();
    }

    function drawDistanceTransform() {
        const maxD = dtransState.maxDist || 1;

        // Draw distance colors
        for(let y = 0; y < GRID_DIM; y++) {
            for(let x = 0; x < GRID_DIM; x++) {
                const d = dtransState.distances[y][x];
                if(d === 0) {
                    // Obstacle
                    gridCtx.fillStyle = "#4b5563";
                } else if(d === Infinity || d === -1) {
                    // Not reached yet (during animation)
                    gridCtx.fillStyle = "#1f2937";
                } else {
                    // Color based on distance
                    const t = d / maxD;
                    gridCtx.fillStyle = distanceToColor(t);
                }
                gridCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);

                // Grid lines
                gridCtx.strokeStyle = "rgba(255,255,255,0.1)";
                gridCtx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }

        // Gradient view: draw arrows pointing away from obstacles
        if(dtransState.view === 'GRADIENT') {
            gridCtx.strokeStyle = "rgba(255,255,255,0.7)";
            gridCtx.lineWidth = 1;
            for(let y = 1; y < GRID_DIM - 1; y += 2) {
                for(let x = 1; x < GRID_DIM - 1; x += 2) {
                    if(dtransState.distances[y][x] <= 0 || dtransState.distances[y][x] === Infinity) continue;

                    // Compute gradient (pointing toward higher distance = away from obstacles)
                    const dx = (dtransState.distances[y][Math.min(x+1, GRID_DIM-1)] - dtransState.distances[y][Math.max(x-1, 0)]) / 2;
                    const dy = (dtransState.distances[Math.min(y+1, GRID_DIM-1)][x] - dtransState.distances[Math.max(y-1, 0)][x]) / 2;
                    const mag = Math.sqrt(dx*dx + dy*dy);
                    if(mag < 0.1) continue;

                    const cx = x * CELL_SIZE + CELL_SIZE / 2;
                    const cy = y * CELL_SIZE + CELL_SIZE / 2;
                    const arrowLen = CELL_SIZE * 0.8;
                    const ex = cx + (dx / mag) * arrowLen;
                    const ey = cy + (dy / mag) * arrowLen;

                    gridCtx.beginPath();
                    gridCtx.moveTo(cx, cy);
                    gridCtx.lineTo(ex, ey);
                    gridCtx.stroke();

                    // Arrow head
                    const angle = Math.atan2(dy, dx);
                    gridCtx.beginPath();
                    gridCtx.moveTo(ex, ey);
                    gridCtx.lineTo(ex - 4 * Math.cos(angle - 0.5), ey - 4 * Math.sin(angle - 0.5));
                    gridCtx.lineTo(ex - 4 * Math.cos(angle + 0.5), ey - 4 * Math.sin(angle + 0.5));
                    gridCtx.closePath();
                    gridCtx.fillStyle = "rgba(255,255,255,0.7)";
                    gridCtx.fill();
                }
            }
            gridCtx.lineWidth = 1;
        }

        // Mark safest point
        const sp = dtransState.safestPoint;
        gridCtx.fillStyle = "#ffffff";
        gridCtx.beginPath();
        gridCtx.arc(sp.x * CELL_SIZE + CELL_SIZE/2, sp.y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/3, 0, Math.PI * 2);
        gridCtx.fill();
        gridCtx.fillStyle = "#000";
        gridCtx.font = "bold 8px monospace";
        gridCtx.textAlign = "center";
        gridCtx.textBaseline = "middle";
        gridCtx.fillText("★", sp.x * CELL_SIZE + CELL_SIZE/2, sp.y * CELL_SIZE + CELL_SIZE/2);
    }

    function distanceToColor(t) {
        // Rainbow gradient: red -> orange -> yellow -> green -> blue -> purple
        const colors = [
            [239, 68, 68],   // red
            [249, 115, 22],  // orange
            [234, 179, 8],   // yellow
            [34, 197, 94],   // green
            [59, 130, 246],  // blue
            [139, 92, 246]   // purple
        ];
        const idx = t * (colors.length - 1);
        const i = Math.floor(idx);
        const f = idx - i;
        if(i >= colors.length - 1) return `rgb(${colors[colors.length-1].join(',')})`;
        const c1 = colors[i], c2 = colors[i + 1];
        const r = Math.round(c1[0] + f * (c2[0] - c1[0]));
        const g = Math.round(c1[1] + f * (c2[1] - c1[1]));
        const b = Math.round(c1[2] + f * (c2[2] - c1[2]));
        return `rgb(${r},${g},${b})`;
    }

    // Visibility Graph / Voronoi state and functions
    let visGraphState = {
        view: 'VISGRAPH', // VISGRAPH or VORONOI
        vertices: [],      // {x, y, type: 'start'|'goal'|'corner'}
        edges: [],         // {from, to, dist}
        shortestPath: [],  // array of vertex indices
        voronoiEdges: []   // for voronoi approximation
    };

    function setVisGraphView(view) {
        visGraphState.view = view;
        document.getElementById('btn-visgraph-vg').className =
            view === 'VISGRAPH' ? "px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
                                : "px-2 py-1 text-xs rounded text-gray-600";
        document.getElementById('btn-visgraph-vor').className =
            view === 'VORONOI' ? "px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
                               : "px-2 py-1 text-xs rounded text-gray-600";

        // Toggle legends and explanations
        document.getElementById('visgraph-legend-vg').classList.toggle('hidden', view !== 'VISGRAPH');
        document.getElementById('visgraph-legend-vor').classList.toggle('hidden', view !== 'VORONOI');
        document.getElementById('visgraph-exp-vg').classList.toggle('hidden', view !== 'VISGRAPH');
        document.getElementById('visgraph-exp-vor').classList.toggle('hidden', view !== 'VORONOI');

        if(view === 'VORONOI') {
            computeVoronoiApprox();
        }
        drawGridScene();
    }

    function buildVisibilityGraph() {
        visGraphState.vertices = [];
        visGraphState.edges = [];
        visGraphState.shortestPath = [];

        // Add start and goal
        const startPx = gridState.start.x * CELL_SIZE + CELL_SIZE / 2;
        const startPy = gridState.start.y * CELL_SIZE + CELL_SIZE / 2;
        const goalPx = gridState.goal.x * CELL_SIZE + CELL_SIZE / 2;
        const goalPy = gridState.goal.y * CELL_SIZE + CELL_SIZE / 2;

        visGraphState.vertices.push({x: startPx, y: startPy, type: 'start'});
        visGraphState.vertices.push({x: goalPx, y: goalPy, type: 'goal'});

        // Find obstacle corners (convex corners of obstacle regions)
        const obstacleCorners = findObstacleCorners();
        for(let corner of obstacleCorners) {
            visGraphState.vertices.push({x: corner.x, y: corner.y, type: 'corner'});
        }

        // Build edges between all visible pairs
        for(let i = 0; i < visGraphState.vertices.length; i++) {
            for(let j = i + 1; j < visGraphState.vertices.length; j++) {
                const v1 = visGraphState.vertices[i];
                const v2 = visGraphState.vertices[j];
                if(isVisible(v1.x, v1.y, v2.x, v2.y)) {
                    const dist = Math.hypot(v2.x - v1.x, v2.y - v1.y);
                    visGraphState.edges.push({from: i, to: j, dist: dist});
                }
            }
        }

        // Find shortest path using Dijkstra
        findShortestPathVisGraph();
    }

    function findObstacleCorners() {
        const corners = [];
        const margin = CELL_SIZE * 0.3; // Small offset from actual corner

        for(let y = 0; y < GRID_DIM; y++) {
            for(let x = 0; x < GRID_DIM; x++) {
                if(gridState.grid[y][x] === 1) continue; // Skip obstacles

                // Check if this is a corner cell (adjacent to obstacle diagonally)
                const checks = [
                    {dx: -1, dy: -1, ox1: -1, oy1: 0, ox2: 0, oy2: -1}, // top-left
                    {dx: 1, dy: -1, ox1: 1, oy1: 0, ox2: 0, oy2: -1},  // top-right
                    {dx: -1, dy: 1, ox1: -1, oy1: 0, ox2: 0, oy2: 1},  // bottom-left
                    {dx: 1, dy: 1, ox1: 1, oy1: 0, ox2: 0, oy2: 1}     // bottom-right
                ];

                for(let c of checks) {
                    const diagX = x + c.dx;
                    const diagY = y + c.dy;
                    const adj1X = x + c.ox1;
                    const adj1Y = y + c.oy1;
                    const adj2X = x + c.ox2;
                    const adj2Y = y + c.oy2;

                    // Check if diagonal cell is obstacle but both adjacent cells are free
                    if(diagX >= 0 && diagX < GRID_DIM && diagY >= 0 && diagY < GRID_DIM &&
                       gridState.grid[diagY][diagX] === 1) {
                        const adj1Free = adj1X < 0 || adj1X >= GRID_DIM || adj1Y < 0 || adj1Y >= GRID_DIM || gridState.grid[adj1Y][adj1X] === 0;
                        const adj2Free = adj2X < 0 || adj2X >= GRID_DIM || adj2Y < 0 || adj2Y >= GRID_DIM || gridState.grid[adj2Y][adj2X] === 0;

                        if(adj1Free && adj2Free) {
                            // This is a convex corner - add vertex offset from the obstacle
                            const cx = x * CELL_SIZE + CELL_SIZE / 2 + c.dx * margin;
                            const cy = y * CELL_SIZE + CELL_SIZE / 2 + c.dy * margin;
                            corners.push({x: cx, y: cy});
                        }
                    }
                }
            }
        }
        return corners;
    }

    function isVisible(x1, y1, x2, y2) {
        // Check if line segment from (x1,y1) to (x2,y2) intersects any obstacle
        const steps = Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1)) / (CELL_SIZE / 4);
        for(let i = 0; i <= steps; i++) {
            const t = i / steps;
            const px = x1 + t * (x2 - x1);
            const py = y1 + t * (y2 - y1);
            const gx = Math.floor(px / CELL_SIZE);
            const gy = Math.floor(py / CELL_SIZE);
            if(gx >= 0 && gx < GRID_DIM && gy >= 0 && gy < GRID_DIM) {
                if(gridState.grid[gy][gx] === 1) return false;
            }
        }
        return true;
    }

    function findShortestPathVisGraph() {
        const n = visGraphState.vertices.length;
        if(n < 2) return;

        const dist = new Array(n).fill(Infinity);
        const prev = new Array(n).fill(-1);
        const visited = new Array(n).fill(false);
        dist[0] = 0; // Start vertex

        // Build adjacency list
        const adj = Array.from({length: n}, () => []);
        for(let e of visGraphState.edges) {
            adj[e.from].push({to: e.to, dist: e.dist});
            adj[e.to].push({to: e.from, dist: e.dist});
        }

        // Dijkstra
        for(let i = 0; i < n; i++) {
            let u = -1;
            for(let j = 0; j < n; j++) {
                if(!visited[j] && (u === -1 || dist[j] < dist[u])) u = j;
            }
            if(u === -1 || dist[u] === Infinity) break;
            visited[u] = true;
            for(let {to, dist: d} of adj[u]) {
                if(dist[u] + d < dist[to]) {
                    dist[to] = dist[u] + d;
                    prev[to] = u;
                }
            }
        }

        // Reconstruct path to goal (vertex 1)
        visGraphState.shortestPath = [];
        let curr = 1;
        while(curr !== -1) {
            visGraphState.shortestPath.unshift(curr);
            curr = prev[curr];
        }
    }

    function computeVoronoiApprox() {
        // Use distance transform to approximate Voronoi edges (ridges)
        if(dtransState.distances.length === 0) {
            computeDistanceTransform();
        }

        visGraphState.voronoiEdges = [];

        // Find ridge points (local maxima in distance field)
        for(let y = 1; y < GRID_DIM - 1; y++) {
            for(let x = 1; x < GRID_DIM - 1; x++) {
                const d = dtransState.distances[y][x];
                if(d <= 0 || d === Infinity) continue;

                // Check if this is a ridge (local maximum in at least one direction)
                const neighbors = [
                    dtransState.distances[y-1][x],
                    dtransState.distances[y+1][x],
                    dtransState.distances[y][x-1],
                    dtransState.distances[y][x+1]
                ];

                // Ridge condition: d is >= both neighbors in at least one axis
                const isHRidge = d >= dtransState.distances[y][x-1] && d >= dtransState.distances[y][x+1];
                const isVRidge = d >= dtransState.distances[y-1][x] && d >= dtransState.distances[y+1][x];

                if(isHRidge || isVRidge) {
                    visGraphState.voronoiEdges.push({
                        x: x * CELL_SIZE + CELL_SIZE / 2,
                        y: y * CELL_SIZE + CELL_SIZE / 2,
                        type: isHRidge && isVRidge ? 'junction' : 'edge'
                    });
                }
            }
        }
    }

    function drawVisibilityGraphView() {
        const showPath = document.getElementById('visgraph-show-path')?.checked ?? true;
        const showAll = document.getElementById('visgraph-show-all')?.checked ?? false;

        // Draw grid cells (obstacles)
        for(let y = 0; y < GRID_DIM; y++) {
            for(let x = 0; x < GRID_DIM; x++) {
                if(gridState.grid[y][x] === 1) {
                    gridCtx.fillStyle = "#4b5563";
                    gridCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
                gridCtx.strokeStyle = "#e5e7eb";
                gridCtx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }

        // Draw all visibility edges (if enabled)
        if(showAll) {
            gridCtx.strokeStyle = "rgba(156, 163, 175, 0.4)";
            gridCtx.lineWidth = 1;
            for(let e of visGraphState.edges) {
                const v1 = visGraphState.vertices[e.from];
                const v2 = visGraphState.vertices[e.to];
                gridCtx.beginPath();
                gridCtx.moveTo(v1.x, v1.y);
                gridCtx.lineTo(v2.x, v2.y);
                gridCtx.stroke();
            }
        }

        // Draw shortest path
        if(showPath && visGraphState.shortestPath.length > 1) {
            gridCtx.strokeStyle = "#22c55e";
            gridCtx.lineWidth = 3;
            gridCtx.beginPath();
            const first = visGraphState.vertices[visGraphState.shortestPath[0]];
            gridCtx.moveTo(first.x, first.y);
            for(let i = 1; i < visGraphState.shortestPath.length; i++) {
                const v = visGraphState.vertices[visGraphState.shortestPath[i]];
                gridCtx.lineTo(v.x, v.y);
            }
            gridCtx.stroke();
            gridCtx.lineWidth = 1;
        }

        // Draw vertices
        for(let v of visGraphState.vertices) {
            gridCtx.beginPath();
            gridCtx.arc(v.x, v.y, 5, 0, Math.PI * 2);
            if(v.type === 'start') {
                gridCtx.fillStyle = "#3b82f6";
            } else if(v.type === 'goal') {
                gridCtx.fillStyle = "#ef4444";
            } else {
                gridCtx.fillStyle = "#fbbf24";
            }
            gridCtx.fill();
            gridCtx.strokeStyle = "#000";
            gridCtx.stroke();
        }
    }

    function drawVoronoiView() {
        // Draw obstacles
        for(let y = 0; y < GRID_DIM; y++) {
            for(let x = 0; x < GRID_DIM; x++) {
                if(gridState.grid[y][x] === 1) {
                    gridCtx.fillStyle = "#4b5563";
                    gridCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
                gridCtx.strokeStyle = "#e5e7eb";
                gridCtx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }

        // Draw Voronoi edges (ridge points)
        gridCtx.fillStyle = "#22d3d1";
        for(let p of visGraphState.voronoiEdges) {
            gridCtx.beginPath();
            gridCtx.arc(p.x, p.y, p.type === 'junction' ? 3 : 2, 0, Math.PI * 2);
            gridCtx.fill();
        }

        // Draw start and goal
        const startPx = gridState.start.x * CELL_SIZE + CELL_SIZE / 2;
        const startPy = gridState.start.y * CELL_SIZE + CELL_SIZE / 2;
        const goalPx = gridState.goal.x * CELL_SIZE + CELL_SIZE / 2;
        const goalPy = gridState.goal.y * CELL_SIZE + CELL_SIZE / 2;

        gridCtx.fillStyle = "#3b82f6";
        gridCtx.beginPath();
        gridCtx.arc(startPx, startPy, 6, 0, Math.PI * 2);
        gridCtx.fill();

        gridCtx.fillStyle = "#ef4444";
        gridCtx.beginPath();
        gridCtx.arc(goalPx, goalPy, 6, 0, Math.PI * 2);
        gridCtx.fill();
    }

    function setGridAlgo(algo) {
        gridState.algo = algo;
        // Update Buttons
        ['astar', 'theta', 'jps', 'dlite'].forEach(k => {
             document.getElementById(`btn-grid-${k}`).className = (k.toUpperCase() === algo)
             ? "px-2 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
             : "px-2 py-1 text-xs rounded text-gray-600";
        });

        // Show/Hide relevant steps
        document.querySelector('.grid-astar-section').style.display = (algo === 'ASTAR' || algo === 'THETA') ? 'block' : 'none';
        document.querySelector('.grid-jps-section').style.display = (algo === 'JPS') ? 'block' : 'none';
        document.querySelector('.grid-dlite-section').style.display = (algo === 'DLITE') ? 'block' : 'none';
        document.getElementById('dlite-hint').style.display = (algo === 'DLITE') ? 'inline' : 'none';

        document.getElementById('step-grid-4').style.display = (algo === 'THETA') ? 'flex' : 'none';

        resetGridLogic();
    }

    function resetGrid() {
        if(gridState.grid.length === 0) {
            for(let y=0; y<GRID_DIM; y++) {
                let row = [];
                for(let x=0; x<GRID_DIM; x++) row.push(0);
                gridState.grid.push(row);
            }
            for(let i=5; i<20; i++) gridState.grid[10][i] = 1;
            for(let i=5; i<15; i++) gridState.grid[i][10] = 1;
        }
        resetGridLogic();
    }
    
    function clearGridWalls() {
        for(let y=0; y<GRID_DIM; y++) {
            for(let x=0; x<GRID_DIM; x++) gridState.grid[y][x] = 0;
        }
        resetGridLogic();
    }

    function gridHeuristic(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function resetGridLogic() {
        stopAuto();
        gridState.openSet = [];
        gridState.closedSet = [];
        gridState.path = [];
        gridState.finished = false;
        gridState.stepState = 0;
        
        if (gridState.algo === 'DLITE') {
            initDLite();
        } else {
            // Init A* / Theta
            let startNode = {x: gridState.start.x, y: gridState.start.y, g: 0, h: 0, f: 0, parent: null};
            startNode.h = gridHeuristic(startNode, gridState.goal);
            startNode.f = startNode.h;
            gridState.openSet.push(startNode);
        }
        
        highlightGridStep(null);
        document.getElementById('grid-cost').textContent = "0";
        document.getElementById('grid-visited').textContent = "0";
        document.getElementById('algo-status').textContent = "Ready.";
        drawGridScene();
    }

    // --- D* Lite Init ---
    function initDLite() {
        gridState.rhs = [];
        gridState.g = [];
        gridState.dLiteQueue = [];
        
        for(let y=0; y<GRID_DIM; y++) {
            let rowR = [], rowG = [];
            for(let x=0; x<GRID_DIM; x++) { rowR.push(Infinity); rowG.push(Infinity); }
            gridState.rhs.push(rowR);
            gridState.g.push(rowG);
        }
        
        // D* Lite plans backward from Goal
        let gx = gridState.goal.x, gy = gridState.goal.y;
        gridState.rhs[gy][gx] = 0;
        
        // Key: [min(g, rhs) + h, min(g, rhs)]
        addToDLiteQueue({x: gx, y: gy}, calcKey({x: gx, y: gy}));
        document.getElementById('algo-status').textContent = "D* Lite Init. Queue: 1";
    }

    function calcKey(n) {
        let val = Math.min(gridState.g[n.y][n.x], gridState.rhs[n.y][n.x]);
        return [val + gridHeuristic(n, gridState.start), val];
    }

    function addToDLiteQueue(n, k) {
        n.k = k;
        gridState.dLiteQueue.push(n);
        gridState.dLiteQueue.sort((a,b) => (a.k[0] - b.k[0]) || (a.k[1] - b.k[1]));
    }

    // --- MAIN ADVANCE ---
    function advanceGrid() {
        if (gridState.algo === 'DLITE') advanceDLite();
        else if (gridState.algo === 'JPS') advanceJPS();
        else advanceAStar();
    }

    function advanceAStar() {
        if(gridState.finished) return;
        
        // Fix: Only fail if list is empty AND we are trying to pop (State 0)
        if(gridState.stepState === 0 && gridState.openSet.length === 0) {
            gridState.finished = true; 
            document.getElementById('algo-status').textContent = "Failed. No Path.";
            return;
        }

        // Two-Step State Machine
        
        if (gridState.stepState === 0) { 
            // STEP 1: POP & SELECT
            // Pick node with lowest F
            let lowestIdx = 0;
            for(let i=0; i<gridState.openSet.length; i++) {
                if(gridState.openSet[i].f < gridState.openSet[lowestIdx].f) lowestIdx = i;
            }
            gridState.current = gridState.openSet[lowestIdx];
            
            document.getElementById('algo-status').textContent = `Selecting Best: [${gridState.current.x},${gridState.current.y}] F=${gridState.current.f.toFixed(1)}`;

            // Check Goal
            if(gridState.current.x === gridState.goal.x && gridState.current.y === gridState.goal.y) {
                gridState.finished = true;
                reconstructGridPath(gridState.current);
                highlightGridStep('step-grid-2');
                document.getElementById('algo-status').textContent = "Goal Reached!";
                return;
            }

            // Move to Closed
            gridState.openSet.splice(lowestIdx, 1);
            gridState.closedSet.push(gridState.current);
            
            highlightGridStep('step-grid-1'); // UI Highlight
            gridState.stepState = 1; // Next time, we expand
            
        } else {
            // STEP 2: EXPAND NEIGHBORS
            let neighbors = getGridNeighbors(gridState.current);
            let count = 0;
            for(let neighbor of neighbors) {
                if(gridState.closedSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) continue;
                if(gridState.grid[neighbor.y][neighbor.x] === 1) continue;

                let tentativeG = gridState.current.g + Math.hypot(gridState.current.x - neighbor.x, gridState.current.y - neighbor.y);
                let parentForNeighbor = gridState.current;

                // Theta* Shortcut Check
                if (gridState.algo === 'THETA' && gridState.current.parent) {
                    if (lineOfSight(gridState.current.parent, neighbor)) {
                        parentForNeighbor = gridState.current.parent;
                        tentativeG = parentForNeighbor.g + Math.hypot(parentForNeighbor.x - neighbor.x, parentForNeighbor.y - neighbor.y);
                    }
                }

                let openNode = gridState.openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
                if(!openNode) {
                    neighbor.g = tentativeG;
                    neighbor.h = gridHeuristic(neighbor, gridState.goal);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = parentForNeighbor;
                    gridState.openSet.push(neighbor);
                    count++;
                } else if (tentativeG < openNode.g) {
                    openNode.g = tentativeG;
                    openNode.f = openNode.g + openNode.h;
                    openNode.parent = parentForNeighbor;
                }
            }
            
            document.getElementById('algo-status').textContent = `Expanded ${count} neighbors.`;
            highlightGridStep('step-grid-3'); // UI Highlight
            if(gridState.algo === 'THETA') highlightGridStep('step-grid-4');
            
            reconstructGridPath(gridState.current);
            document.getElementById('grid-visited').textContent = gridState.closedSet.length;
            gridState.stepState = 0; // Go back to Pop
        }
    }

    // --- JPS (Jump Point Search) ---
    function isWalkable(x, y) {
        if (x < 0 || x >= GRID_DIM || y < 0 || y >= GRID_DIM) return false;
        return gridState.grid[y][x] === 0;
    }

    function jump(x, y, dx, dy, start, goal) {
        let nx = x + dx;
        let ny = y + dy;

        if (!isWalkable(nx, ny)) return null;

        if (nx === goal.x && ny === goal.y) return {x: nx, y: ny};

        // Check for forced neighbors (diagonal movement)
        if (dx !== 0 && dy !== 0) {
            // Diagonal case
            if ((!isWalkable(x - dx, y) && isWalkable(x - dx, y + dy)) ||
                (!isWalkable(x, y - dy) && isWalkable(x + dx, y - dy))) {
                return {x: nx, y: ny};
            }
            // Recurse horizontally and vertically
            if (jump(nx, ny, dx, 0, start, goal) !== null ||
                jump(nx, ny, 0, dy, start, goal) !== null) {
                return {x: nx, y: ny};
            }
        } else {
            // Horizontal or vertical
            if (dx !== 0) {
                if ((!isWalkable(nx, y - 1) && isWalkable(nx + dx, y - 1)) ||
                    (!isWalkable(nx, y + 1) && isWalkable(nx + dx, y + 1))) {
                    return {x: nx, y: ny};
                }
            } else {
                if ((!isWalkable(x - 1, ny) && isWalkable(x - 1, ny + dy)) ||
                    (!isWalkable(x + 1, ny) && isWalkable(x + 1, ny + dy))) {
                    return {x: nx, y: ny};
                }
            }
        }

        // Continue jumping
        return jump(nx, ny, dx, dy, start, goal);
    }

    function getJPSSuccessors(node) {
        let successors = [];
        let parent = node.parent;
        let x = node.x, y = node.y;

        // If no parent (start node), check all 8 directions
        if (!parent) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    let jp = jump(x, y, dx, dy, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
            }
        } else {
            // Prune directions based on parent
            let dx = Math.sign(x - parent.x);
            let dy = Math.sign(y - parent.y);

            if (dx !== 0 && dy !== 0) {
                // Diagonal movement: check straight, diagonal, and forced
                if (isWalkable(x, y + dy)) {
                    let jp = jump(x, y, 0, dy, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
                if (isWalkable(x + dx, y)) {
                    let jp = jump(x, y, dx, 0, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
                if (isWalkable(x + dx, y + dy)) {
                    let jp = jump(x, y, dx, dy, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
                // Forced neighbors
                if (!isWalkable(x - dx, y) && isWalkable(x - dx, y + dy)) {
                    let jp = jump(x, y, -dx, dy, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
                if (!isWalkable(x, y - dy) && isWalkable(x + dx, y - dy)) {
                    let jp = jump(x, y, dx, -dy, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
            } else if (dx !== 0) {
                // Horizontal movement
                if (isWalkable(x + dx, y)) {
                    let jp = jump(x, y, dx, 0, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
                // Forced neighbors
                if (!isWalkable(x, y - 1) && isWalkable(x + dx, y - 1)) {
                    let jp = jump(x, y, dx, -1, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
                if (!isWalkable(x, y + 1) && isWalkable(x + dx, y + 1)) {
                    let jp = jump(x, y, dx, 1, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
            } else {
                // Vertical movement
                if (isWalkable(x, y + dy)) {
                    let jp = jump(x, y, 0, dy, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
                // Forced neighbors
                if (!isWalkable(x - 1, y) && isWalkable(x - 1, y + dy)) {
                    let jp = jump(x, y, -1, dy, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
                if (!isWalkable(x + 1, y) && isWalkable(x + 1, y + dy)) {
                    let jp = jump(x, y, 1, dy, gridState.start, gridState.goal);
                    if (jp) successors.push(jp);
                }
            }
        }
        return successors;
    }

    function advanceJPS() {
        if (gridState.finished) return;

        if (gridState.stepState === 0 && gridState.openSet.length === 0) {
            gridState.finished = true;
            document.getElementById('algo-status').textContent = "Failed. No Path.";
            return;
        }

        if (gridState.stepState === 0) {
            // STEP 1: POP lowest F
            let lowestIdx = 0;
            for (let i = 0; i < gridState.openSet.length; i++) {
                if (gridState.openSet[i].f < gridState.openSet[lowestIdx].f) lowestIdx = i;
            }
            gridState.current = gridState.openSet[lowestIdx];

            document.getElementById('algo-status').textContent = `JPS: Selecting [${gridState.current.x},${gridState.current.y}] F=${gridState.current.f.toFixed(1)}`;

            // Check Goal
            if (gridState.current.x === gridState.goal.x && gridState.current.y === gridState.goal.y) {
                gridState.finished = true;
                reconstructGridPath(gridState.current);
                highlightGridStep('step-jps-2');
                document.getElementById('algo-status').textContent = "JPS: Goal Reached!";
                return;
            }

            gridState.openSet.splice(lowestIdx, 1);
            gridState.closedSet.push(gridState.current);

            highlightGridStep('step-jps-1');
            gridState.stepState = 1;

        } else {
            // STEP 2: Find jump point successors
            let successors = getJPSSuccessors(gridState.current);
            let count = 0;

            for (let jp of successors) {
                if (gridState.closedSet.some(n => n.x === jp.x && n.y === jp.y)) continue;

                let tentativeG = gridState.current.g + Math.hypot(gridState.current.x - jp.x, gridState.current.y - jp.y);
                let openNode = gridState.openSet.find(n => n.x === jp.x && n.y === jp.y);

                if (!openNode) {
                    jp.g = tentativeG;
                    jp.h = gridHeuristic(jp, gridState.goal);
                    jp.f = jp.g + jp.h;
                    jp.parent = gridState.current;
                    gridState.openSet.push(jp);
                    count++;
                } else if (tentativeG < openNode.g) {
                    openNode.g = tentativeG;
                    openNode.f = openNode.g + openNode.h;
                    openNode.parent = gridState.current;
                }
            }

            document.getElementById('algo-status').textContent = `JPS: Found ${count} jump points.`;
            highlightGridStep('step-jps-3');

            reconstructGridPath(gridState.current);
            document.getElementById('grid-visited').textContent = gridState.closedSet.length;
            gridState.stepState = 0;
        }
    }

    function advanceDLite() {
        // Increase speed for D* Lite
        let iterations = 0;
        while(iterations < 50) { // Very fast per frame
            if(gridState.dLiteQueue.length === 0) {
                gridState.finished = true;
                document.getElementById('algo-status').textContent = "D* Lite: Converged (Empty Queue)";
                break;
            }

            let startKey = calcKey(gridState.start);
            let topNode = gridState.dLiteQueue[0];
            
            let cond = false;
            // Key check: Top < Start
            if (topNode.k[0] < startKey[0] - 0.0001 || (Math.abs(topNode.k[0] - startKey[0]) < 0.0001 && topNode.k[1] < startKey[1] - 0.0001)) cond = true;
            // Consistency check: rhs != g
            if (gridState.rhs[gridState.start.y][gridState.start.x] !== gridState.g[gridState.start.y][gridState.start.x]) cond = true;

            if (!cond) {
                gridState.finished = true;
                highlightGridStep(null);
                document.getElementById('algo-status').textContent = "D* Lite: Converged (Consistent)";
                break;
            }

            // Pop
            gridState.current = gridState.dLiteQueue.shift(); 
            let u = gridState.current;
            if(!u) break;

            let gx = u.x, gy = u.y;
            let g_val = gridState.g[gy][gx];
            let rhs_val = gridState.rhs[gy][gx];
            
            // Consistency Check & Propagate
            if (g_val > rhs_val) {
                gridState.g[gy][gx] = rhs_val; 
                let neighbors = getGridNeighbors(u);
                neighbors.forEach(n => updateDLiteVertex(n));
            } else {
                gridState.g[gy][gx] = Infinity;
                updateDLiteVertex(u);
                let neighbors = getGridNeighbors(u);
                neighbors.forEach(n => updateDLiteVertex(n));
            }
            iterations++;
        }
        
        highlightGridStep('step-dlite-3');
        document.getElementById('grid-visited').textContent = "Q: " + gridState.dLiteQueue.length;
        extractDLitePath();
    }

    function updateDLiteVertex(u) {
        if (u.x !== gridState.goal.x || u.y !== gridState.goal.y) {
            let minRHS = Infinity;
            let neighbors = getGridNeighbors(u);
            for(let n of neighbors) {
                if(gridState.grid[u.y][u.x] === 0 && gridState.grid[n.y][n.x] === 0) {
                     let cost = Math.hypot(u.x - n.x, u.y - n.y);
                     minRHS = Math.min(minRHS, cost + gridState.g[n.y][n.x]);
                }
            }
            gridState.rhs[u.y][u.x] = minRHS;
        }
        
        gridState.dLiteQueue = gridState.dLiteQueue.filter(n => n.x !== u.x || n.y !== u.y);
        
        if (gridState.g[u.y][u.x] !== gridState.rhs[u.y][u.x]) {
            addToDLiteQueue(u, calcKey(u));
        }
        gridState.dLiteQueue.sort((a,b) => (a.k[0] - b.k[0]) || (a.k[1] - b.k[1]));
    }
    
    function extractDLitePath() {
        gridState.path = [];
        let curr = gridState.start;
        let limit = 0;
        let maxLimit = GRID_DIM * GRID_DIM;
        
        while(limit < maxLimit) {
            gridState.path.push(curr);
            if(curr.x === gridState.goal.x && curr.y === gridState.goal.y) break;
            
            let minVal = Infinity;
            let next = null;
            let neighbors = getGridNeighbors(curr);
            
            for(let n of neighbors) {
                 if (gridState.grid[n.y][n.x] === 1) continue;
                 let val = gridState.g[n.y][n.x] + Math.hypot(curr.x - n.x, curr.y - n.y);
                 if (val < minVal) {
                     minVal = val;
                     next = n;
                 }
            }
            
            if(next && minVal < Infinity) curr = next;
            else break;
            limit++;
        }
        
        if (gridState.path.length > 0) {
             let c = 0;
             for(let i=0; i<gridState.path.length-1; i++) {
                 c += Math.hypot(gridState.path[i].x - gridState.path[i+1].x, gridState.path[i].y - gridState.path[i+1].y);
             }
             document.getElementById('grid-cost').textContent = c.toFixed(2);
        } else {
             document.getElementById('grid-cost').textContent = "Inf";
        }
    }

    // --- Helpers ---

    function getGridNeighbors(node) {
        let res = [];
        for(let dy=-1; dy<=1; dy++) {
            for(let dx=-1; dx<=1; dx++) {
                if(dx===0 && dy===0) continue;
                let nx = node.x + dx;
                let ny = node.y + dy;
                if(nx >= 0 && nx < GRID_DIM && ny >= 0 && ny < GRID_DIM) {
                    res.push({x: nx, y: ny});
                }
            }
        }
        return res;
    }

    function lineOfSight(n1, n2) {
        let x0 = n1.x; let y0 = n1.y;
        let x1 = n2.x; let y1 = n2.y;
        let dx = Math.abs(x1 - x0);
        let dy = Math.abs(y1 - y0);
        let sx = (x0 < x1) ? 1 : -1;
        let sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;
        while(true) {
            if(gridState.grid[y0][x0] === 1) return false;
            if(x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if(e2 > -dy) { err -= dy; x0 += sx; }
            if(e2 < dx) { err += dx; y0 += sy; }
        }
        return true;
    }

    function reconstructGridPath(node) {
        gridState.path = [];
        let curr = node;
        while(curr) {
            gridState.path.push(curr);
            curr = curr.parent;
        }
        if(gridState.path.length > 0) {
             document.getElementById('grid-cost').textContent = gridState.path[0].g.toFixed(2);
        }
    }

    function highlightGridStep(id) {
         document.querySelectorAll('#grid-steps-container .step-item').forEach(e => e.classList.remove('active'));
         if(id) document.getElementById(id).classList.add('active');
    }

    function stepGridOnce() {
        stopAuto();
        advanceGrid();
        drawGridScene();
    }
    
    // Grid Mouse Interactions
    gridCanvas.addEventListener('mousedown', e => {
        if(currentView !== VIEWS.GRID) return;
        const rect = gridCanvas.getBoundingClientRect();
        const gx = Math.floor((e.clientX - rect.left) / (rect.width / GRID_DIM));
        const gy = Math.floor((e.clientY - rect.top) / (rect.height / GRID_DIM));

        // C-Space mode: move the robot
        if(gridState.cspaceMode) {
            cspaceState.robotPos = {x: gx, y: gy};
            drawGridScene();
            return;
        }

        if(e.button === 0 && !e.shiftKey) { // Left Click = Wall
             if(gx === gridState.start.x && gy === gridState.start.y) return;
             if(gx === gridState.goal.x && gy === gridState.goal.y) return;
             gridState.grid[gy][gx] = gridState.grid[gy][gx] === 0 ? 1 : 0;
             
             // D* Lite Replanning Trigger
             if (gridState.algo === 'DLITE') {
                 let affected = getGridNeighbors({x: gx, y: gy});
                 affected.push({x: gx, y: gy}); 
                 affected.forEach(n => {
                     updateDLiteVertex(n);
                 });
                 gridState.finished = false; 
                 document.getElementById('algo-status').textContent = "D* Lite: Map Changed (Updating)";
             }
        } else if (e.button === 2) { // Right Click = Start
             gridState.start = {x: gx, y: gy};
             gridState.grid[gy][gx] = 0; 
             if(gridState.algo === 'DLITE') { gridState.finished = false; } 
        } else if (e.shiftKey) { // Shift+Click = Goal
             gridState.goal = {x: gx, y: gy};
             gridState.grid[gy][gx] = 0; 
             if(gridState.algo === 'DLITE') initDLite(); 
        }
        
        if (gridState.algo !== 'DLITE') resetGridLogic();
        drawGridScene();
    });
    gridCanvas.addEventListener('contextmenu', e => e.preventDefault());

    function drawGridScene() {
        gridCtx.clearRect(0,0,SIZE,SIZE);

        // C-Space visualization mode
        if(gridState.cspaceMode) {
            drawCSpaceVisualization();
            return;
        }

        // Distance Transform visualization mode
        if(gridState.dtransMode) {
            drawDistanceTransform();
            return;
        }

        // Visibility Graph / Voronoi visualization mode
        if(gridState.visGraphMode) {
            if(visGraphState.view === 'VISGRAPH') {
                drawVisibilityGraphView();
            } else {
                drawVoronoiView();
            }
            return;
        }

        // Draw Cells
        for(let y=0; y<GRID_DIM; y++) {
            for(let x=0; x<GRID_DIM; x++) {
                gridCtx.strokeStyle = "#e5e7eb";
                gridCtx.strokeRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
                if(gridState.grid[y][x] === 1) {
                    gridCtx.fillStyle = "#4b5563";
                    gridCtx.fillRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }

        // Draw Sets (Open/Closed)
        if(gridState.algo === 'DLITE') {
             for(let y=0; y<GRID_DIM; y++) {
                for(let x=0; x<GRID_DIM; x++) {
                    if(gridState.g[y][x] !== Infinity) {
                         gridCtx.fillStyle = "rgba(144, 238, 144, 0.5)"; // Light Green
                         gridCtx.fillRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                    if(gridState.rhs[y][x] !== gridState.g[y][x]) {
                        gridCtx.fillStyle = "rgba(255, 255, 0, 0.6)"; // Yellow
                        gridCtx.fillRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        } else {
            // Make colors bolder!
            gridState.closedSet.forEach(n => {
                gridCtx.fillStyle = "rgba(239, 68, 68, 0.3)"; // Reddish (Closed)
                gridCtx.fillRect(n.x*CELL_SIZE, n.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
            });
            gridState.openSet.forEach(n => {
                gridCtx.fillStyle = "rgba(34, 197, 94, 0.4)"; // Greenish (Open)
                gridCtx.fillRect(n.x*CELL_SIZE, n.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
            });
        }

        // Draw Path
        if(gridState.path.length > 0) {
            gridCtx.beginPath();
            gridCtx.moveTo(gridState.path[0].x * CELL_SIZE + CELL_SIZE/2, gridState.path[0].y * CELL_SIZE + CELL_SIZE/2);
            for(let i=1; i<gridState.path.length; i++) {
                gridCtx.lineTo(gridState.path[i].x * CELL_SIZE + CELL_SIZE/2, gridState.path[i].y * CELL_SIZE + CELL_SIZE/2);
            }
            gridCtx.strokeStyle = "blue";
            gridCtx.lineWidth = 3;
            gridCtx.stroke();
        }

        // Start / Goal
        gridCtx.fillStyle = "green";
        gridCtx.fillRect(gridState.start.x*CELL_SIZE + 2, gridState.start.y*CELL_SIZE + 2, CELL_SIZE-4, CELL_SIZE-4);
        gridCtx.fillStyle = "red";
        gridCtx.fillRect(gridState.goal.x*CELL_SIZE + 2, gridState.goal.y*CELL_SIZE + 2, CELL_SIZE-4, CELL_SIZE-4);

        // Current Head
        if(gridState.current) {
             gridCtx.fillStyle = "orange";
             gridCtx.beginPath();
             gridCtx.arc(gridState.current.x*CELL_SIZE + CELL_SIZE/2, gridState.current.y*CELL_SIZE + CELL_SIZE/2, 5, 0, Math.PI*2);
             gridCtx.fill();
             gridCtx.strokeStyle = "white";
             gridCtx.lineWidth = 1;
             gridCtx.stroke();
        }
    }

    function drawCSpaceVisualization() {
        const robotR = cspaceState.robotRadius * CELL_SIZE;
        const view = cspaceState.view;

        // Background
        gridCtx.fillStyle = "#f0f9ff";
        gridCtx.fillRect(0, 0, SIZE, SIZE);

        // Draw grid lines
        gridCtx.strokeStyle = "#e5e7eb";
        gridCtx.lineWidth = 0.5;
        for(let i = 0; i <= GRID_DIM; i++) {
            gridCtx.beginPath();
            gridCtx.moveTo(i * CELL_SIZE, 0);
            gridCtx.lineTo(i * CELL_SIZE, SIZE);
            gridCtx.stroke();
            gridCtx.beginPath();
            gridCtx.moveTo(0, i * CELL_SIZE);
            gridCtx.lineTo(SIZE, i * CELL_SIZE);
            gridCtx.stroke();
        }

        // Draw C-obstacles (expanded) - shown in CSPACE and BOTH views
        if(view === 'CSPACE' || view === 'BOTH') {
            gridCtx.fillStyle = "rgba(252, 165, 165, 0.6)"; // Red tint for C-obstacle
            for(let y = 0; y < GRID_DIM; y++) {
                for(let x = 0; x < GRID_DIM; x++) {
                    if(gridState.grid[y] && gridState.grid[y][x] === 1) {
                        // Draw expanded obstacle (Minkowski sum approximation)
                        let cx = x * CELL_SIZE + CELL_SIZE/2;
                        let cy = y * CELL_SIZE + CELL_SIZE/2;
                        gridCtx.beginPath();
                        gridCtx.arc(cx, cy, CELL_SIZE/2 + robotR, 0, Math.PI * 2);
                        gridCtx.fill();
                    }
                }
            }
        }

        // Draw original obstacles - shown in WORKSPACE and BOTH views
        if(view === 'WORKSPACE' || view === 'BOTH') {
            gridCtx.fillStyle = "#4b5563";
            for(let y = 0; y < GRID_DIM; y++) {
                for(let x = 0; x < GRID_DIM; x++) {
                    if(gridState.grid[y] && gridState.grid[y][x] === 1) {
                        gridCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        // Draw robot position
        let rx = cspaceState.robotPos.x * CELL_SIZE + CELL_SIZE/2;
        let ry = cspaceState.robotPos.y * CELL_SIZE + CELL_SIZE/2;

        // In WORKSPACE or BOTH: draw robot as disk
        if(view === 'WORKSPACE' || view === 'BOTH') {
            gridCtx.beginPath();
            gridCtx.arc(rx, ry, robotR, 0, Math.PI * 2);
            gridCtx.fillStyle = "rgba(59, 130, 246, 0.7)";
            gridCtx.fill();
            gridCtx.strokeStyle = "#1e40af";
            gridCtx.lineWidth = 2;
            gridCtx.stroke();
        }

        // In CSPACE or BOTH: draw robot as point
        if(view === 'CSPACE' || view === 'BOTH') {
            gridCtx.beginPath();
            gridCtx.arc(rx, ry, 4, 0, Math.PI * 2);
            gridCtx.fillStyle = "#1e3a8a";
            gridCtx.fill();
            gridCtx.strokeStyle = "white";
            gridCtx.lineWidth = 1;
            gridCtx.stroke();
        }

        // Label
        gridCtx.fillStyle = "#1f2937";
        gridCtx.font = "bold 14px sans-serif";
        let label = view === 'WORKSPACE' ? "Workspace (W)" :
                    view === 'CSPACE' ? "Configuration Space (C)" : "Workspace + C-Space";
        gridCtx.fillText(label, 10, 25);

        // Instructions
        gridCtx.font = "11px sans-serif";
        gridCtx.fillStyle = "#6b7280";
        gridCtx.fillText("Click to move robot", 10, SIZE - 10);
    }

    // ==========================================
    // PART 4: EXPLORATION / OCCUPANCY GRID
    // ==========================================
    const exploreCanvas = document.getElementById('exploreCanvas');
    const exploreCtx = exploreCanvas.getContext('2d');

    const EXPLORE_DIM = 50; // 50x50 grid
    const EXPLORE_CELL = SIZE / EXPLORE_DIM;

    let exploreState = {
        grid: [], // 0=unknown, 1=free, 2=obstacle
        robot: { x: 25, y: 25, heading: 0 },
        frontiers: [],
        targetFrontier: null,
        sensor: 'LASER', // LASER or SONAR
        sensorRange: 8,
        stepState: 0,
        obstacles: []
    };

    function initExploreGrid() {
        exploreState.grid = [];
        for(let y = 0; y < EXPLORE_DIM; y++) {
            let row = [];
            for(let x = 0; x < EXPLORE_DIM; x++) {
                row.push(0); // Unknown
            }
            exploreState.grid.push(row);
        }
        // Add border walls
        for(let i = 0; i < EXPLORE_DIM; i++) {
            exploreState.grid[0][i] = 2;
            exploreState.grid[EXPLORE_DIM-1][i] = 2;
            exploreState.grid[i][0] = 2;
            exploreState.grid[i][EXPLORE_DIM-1] = 2;
        }
    }

    function resetExplore() {
        stopAuto();
        initExploreGrid();
        exploreState.frontiers = [];
        exploreState.targetFrontier = null;
        exploreState.stepState = 0;
        exploreState.stuckCounter = 0;
        exploreState.blacklist = [];
        exploreState.obstacles = [];
        addRandomObstacles();
        // Place robot in a guaranteed free spot
        placeRobotInFreeSpace();
        drawExploreScene();
        updateExploreStats();
    }

    function placeRobotInFreeSpace() {
        // Try center first, then search outward for free space
        const centerX = Math.floor(EXPLORE_DIM / 2);
        const centerY = Math.floor(EXPLORE_DIM / 2);

        // Spiral search from center to find free space
        for(let radius = 0; radius < EXPLORE_DIM / 2; radius++) {
            for(let dy = -radius; dy <= radius; dy++) {
                for(let dx = -radius; dx <= radius; dx++) {
                    if(Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue; // Only check perimeter
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if(x > 1 && x < EXPLORE_DIM - 2 && y > 1 && y < EXPLORE_DIM - 2) {
                        if(!isObstacle(x, y) && !isNearObstacle(x, y, 2)) {
                            exploreState.robot = { x: x, y: y, heading: 0 };
                            return;
                        }
                    }
                }
            }
        }
        // Fallback: just place at center
        exploreState.robot = { x: centerX, y: centerY, heading: 0 };
    }

    function isNearObstacle(x, y, margin) {
        for(let dy = -margin; dy <= margin; dy++) {
            for(let dx = -margin; dx <= margin; dx++) {
                if(isObstacle(x + dx, y + dy)) return true;
            }
        }
        return false;
    }

    function addRandomObstacles() {
        // Add some random rectangular obstacles, avoiding center area
        const centerX = Math.floor(EXPLORE_DIM / 2);
        const centerY = Math.floor(EXPLORE_DIM / 2);
        const safeRadius = 8; // Keep center area clear for robot spawn

        for(let i = 0; i < 6; i++) {
            let ox, oy, ow, oh;
            let attempts = 0;
            do {
                ox = Math.floor(Math.random() * (EXPLORE_DIM - 15)) + 5;
                oy = Math.floor(Math.random() * (EXPLORE_DIM - 15)) + 5;
                ow = Math.floor(Math.random() * 8) + 3;
                oh = Math.floor(Math.random() * 8) + 3;
                attempts++;
            } while(attempts < 20 &&
                    ox < centerX + safeRadius && ox + ow > centerX - safeRadius &&
                    oy < centerY + safeRadius && oy + oh > centerY - safeRadius);

            exploreState.obstacles.push({x: ox, y: oy, w: ow, h: oh});
        }
    }

    function setExploreSensor(sensor) {
        exploreState.sensor = sensor;
        document.getElementById('btn-sensor-laser').className = sensor === 'LASER'
            ? "px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
            : "px-3 py-1 text-xs rounded text-gray-600";
        document.getElementById('btn-sensor-sonar').className = sensor === 'SONAR'
            ? "px-3 py-1 text-xs rounded bg-white shadow font-bold text-blue-600"
            : "px-3 py-1 text-xs rounded text-gray-600";
    }

    function switchExploreTab(tab) {
        document.getElementById('tab-EXPLORE-CTRL').classList.toggle('active', tab === 'CTRL');
        document.getElementById('tab-EXPLORE-EDU').classList.toggle('active', tab === 'EDU');
        document.getElementById('section-EXPLORE-CTRL').classList.toggle('active', tab === 'CTRL');
        document.getElementById('section-EXPLORE-EDU').classList.toggle('active', tab === 'EDU');
    }

    function isObstacle(gx, gy) {
        for(let obs of exploreState.obstacles) {
            if(gx >= obs.x && gx < obs.x + obs.w && gy >= obs.y && gy < obs.y + obs.h) {
                return true;
            }
        }
        return false;
    }

    function senseEnvironment() {
        let rx = exploreState.robot.x;
        let ry = exploreState.robot.y;
        let range = exploreState.sensorRange;

        if(exploreState.sensor === 'LASER') {
            // Laser: multiple narrow beams
            for(let angle = 0; angle < Math.PI * 2; angle += Math.PI / 16) {
                for(let d = 1; d <= range; d++) {
                    let cx = Math.round(rx + d * Math.cos(angle));
                    let cy = Math.round(ry + d * Math.sin(angle));
                    if(cx < 0 || cx >= EXPLORE_DIM || cy < 0 || cy >= EXPLORE_DIM) break;
                    if(isObstacle(cx, cy) || exploreState.grid[cy][cx] === 2) {
                        exploreState.grid[cy][cx] = 2; // Obstacle
                        break;
                    } else {
                        exploreState.grid[cy][cx] = 1; // Free
                    }
                }
            }
        } else {
            // Sonar: wider cone, less precise
            for(let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                for(let spread = -0.2; spread <= 0.2; spread += 0.1) {
                    let a = angle + spread;
                    for(let d = 1; d <= range; d++) {
                        let cx = Math.round(rx + d * Math.cos(a));
                        let cy = Math.round(ry + d * Math.sin(a));
                        if(cx < 0 || cx >= EXPLORE_DIM || cy < 0 || cy >= EXPLORE_DIM) break;
                        if(isObstacle(cx, cy) || exploreState.grid[cy][cx] === 2) {
                            exploreState.grid[cy][cx] = 2;
                            break;
                        } else {
                            if(exploreState.grid[cy][cx] === 0) {
                                exploreState.grid[cy][cx] = 1;
                            }
                        }
                    }
                }
            }
        }
    }

    function detectFrontiers() {
        exploreState.frontiers = [];
        for(let y = 1; y < EXPLORE_DIM - 1; y++) {
            for(let x = 1; x < EXPLORE_DIM - 1; x++) {
                if(exploreState.grid[y][x] === 1) { // Free cell
                    // Check if adjacent to unknown
                    let hasUnknown = false;
                    for(let dy = -1; dy <= 1; dy++) {
                        for(let dx = -1; dx <= 1; dx++) {
                            if(exploreState.grid[y+dy][x+dx] === 0) {
                                hasUnknown = true;
                            }
                        }
                    }
                    if(hasUnknown) {
                        exploreState.frontiers.push({x: x, y: y});
                    }
                }
            }
        }
    }

    function selectBestFrontier() {
        if(exploreState.frontiers.length === 0) {
            exploreState.targetFrontier = null;
            return;
        }

        // Initialize blacklist if needed
        if(!exploreState.blacklist) exploreState.blacklist = [];

        // Clean old blacklist entries (frontiers that no longer exist)
        exploreState.blacklist = exploreState.blacklist.filter(bf =>
            exploreState.frontiers.some(f => f.x === bf.x && f.y === bf.y)
        );

        // Select nearest non-blacklisted frontier
        let best = null;
        let bestDist = Infinity;
        for(let f of exploreState.frontiers) {
            // Skip blacklisted frontiers
            if(exploreState.blacklist.some(bf => bf.x === f.x && bf.y === f.y)) continue;

            let d = Math.hypot(f.x - exploreState.robot.x, f.y - exploreState.robot.y);
            if(d < bestDist) {
                bestDist = d;
                best = f;
            }
        }

        // If all frontiers blacklisted, clear blacklist and pick any
        if(!best && exploreState.frontiers.length > 0) {
            exploreState.blacklist = [];
            for(let f of exploreState.frontiers) {
                let d = Math.hypot(f.x - exploreState.robot.x, f.y - exploreState.robot.y);
                if(d < bestDist) {
                    bestDist = d;
                    best = f;
                }
            }
        }

        exploreState.targetFrontier = best;
    }

    function moveTowardsFrontier() {
        if(!exploreState.targetFrontier) return;

        const tx = exploreState.targetFrontier.x;
        const ty = exploreState.targetFrontier.y;
        const rx = exploreState.robot.x;
        const ry = exploreState.robot.y;

        let dist = Math.hypot(tx - rx, ty - ry);
        if(dist < 1.5) {
            exploreState.targetFrontier = null;
            return;
        }

        // Try all 8 directions, pick the best valid move
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1},
            {dx: 1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: -1, dy: -1}
        ];

        let bestMove = null;
        let bestScore = Infinity;

        for(let dir of directions) {
            const nx = rx + dir.dx;
            const ny = ry + dir.dy;

            // Check if valid move
            if(nx <= 0 || nx >= EXPLORE_DIM-1 || ny <= 0 || ny >= EXPLORE_DIM-1) continue;
            if(isObstacle(nx, ny) || exploreState.grid[ny][nx] === 2) continue;

            // Score = distance to target (lower is better)
            const newDist = Math.hypot(tx - nx, ty - ny);
            // Add small penalty for diagonal to prefer cardinal directions when equal
            const score = newDist + (dir.dx !== 0 && dir.dy !== 0 ? 0.01 : 0);

            if(score < bestScore) {
                bestScore = score;
                bestMove = {x: nx, y: ny};
            }
        }

        if(bestMove) {
            exploreState.robot.x = bestMove.x;
            exploreState.robot.y = bestMove.y;
            exploreState.stuckCounter = 0;
        } else {
            // Stuck! Increment counter and try to find alternative
            exploreState.stuckCounter = (exploreState.stuckCounter || 0) + 1;

            if(exploreState.stuckCounter > 2) {
                // Blacklist this frontier - it's unreachable
                if(exploreState.targetFrontier) {
                    if(!exploreState.blacklist) exploreState.blacklist = [];
                    exploreState.blacklist.push({
                        x: exploreState.targetFrontier.x,
                        y: exploreState.targetFrontier.y
                    });
                }
                exploreState.targetFrontier = null;
                exploreState.stuckCounter = 0;

                // Try to move to any free adjacent cell to get unstuck
                const shuffled = [...directions].sort(() => Math.random() - 0.5);
                for(let dir of shuffled) {
                    const nx = rx + dir.dx;
                    const ny = ry + dir.dy;
                    if(nx > 0 && nx < EXPLORE_DIM-1 && ny > 0 && ny < EXPLORE_DIM-1) {
                        if(!isObstacle(nx, ny) && exploreState.grid[ny][nx] !== 2) {
                            exploreState.robot.x = nx;
                            exploreState.robot.y = ny;
                            break;
                        }
                    }
                }
            }
        }
    }

    function advanceExplore() {
        // Cycle through exploration steps
        exploreState.stepState = (exploreState.stepState % 5) + 1;

        highlightExploreStep(exploreState.stepState);

        if(exploreState.stepState === 1) {
            senseEnvironment();
            document.getElementById('explore-status').textContent = "Sensing...";
        } else if(exploreState.stepState === 2) {
            document.getElementById('explore-status').textContent = "Updating grid...";
        } else if(exploreState.stepState === 3) {
            detectFrontiers();
            document.getElementById('explore-status').textContent = `Found ${exploreState.frontiers.length} frontier cells`;
        } else if(exploreState.stepState === 4) {
            selectBestFrontier();
            document.getElementById('explore-status').textContent = exploreState.targetFrontier
                ? `Target: (${exploreState.targetFrontier.x}, ${exploreState.targetFrontier.y})`
                : "No frontiers - exploration complete!";
        } else if(exploreState.stepState === 5) {
            moveTowardsFrontier();
            document.getElementById('explore-status').textContent = `Robot at (${exploreState.robot.x}, ${exploreState.robot.y})`;
        }

        updateExploreStats();
    }

    function stepExploreOnce() {
        stopAuto();
        advanceExplore();
        drawExploreScene();
    }

    function highlightExploreStep(step) {
        for(let i = 1; i <= 5; i++) {
            let el = document.getElementById(`step-explore-${i}`);
            if(el) el.classList.toggle('active', i === step);
        }
    }

    function updateExploreStats() {
        let total = 0, explored = 0;
        for(let y = 0; y < EXPLORE_DIM; y++) {
            for(let x = 0; x < EXPLORE_DIM; x++) {
                total++;
                if(exploreState.grid[y][x] !== 0) explored++;
            }
        }
        document.getElementById('explore-percent').textContent = Math.round(100 * explored / total);
        document.getElementById('frontier-count').textContent = exploreState.frontiers.length;
    }

    function drawExploreScene() {
        exploreCtx.clearRect(0, 0, SIZE, SIZE);

        // Draw grid cells
        for(let y = 0; y < EXPLORE_DIM; y++) {
            for(let x = 0; x < EXPLORE_DIM; x++) {
                let state = exploreState.grid[y][x];
                if(isObstacle(x, y) && state !== 2) {
                    // Hidden obstacle (not yet detected)
                    exploreCtx.fillStyle = "#d1d5db"; // Gray unknown
                } else if(state === 0) {
                    exploreCtx.fillStyle = "#d1d5db"; // Unknown
                } else if(state === 1) {
                    exploreCtx.fillStyle = "#ffffff"; // Free
                } else {
                    exploreCtx.fillStyle = "#374151"; // Obstacle
                }
                exploreCtx.fillRect(x * EXPLORE_CELL, y * EXPLORE_CELL, EXPLORE_CELL, EXPLORE_CELL);
            }
        }

        // Draw grid lines
        exploreCtx.strokeStyle = "#e5e7eb";
        exploreCtx.lineWidth = 0.5;
        for(let i = 0; i <= EXPLORE_DIM; i++) {
            exploreCtx.beginPath();
            exploreCtx.moveTo(i * EXPLORE_CELL, 0);
            exploreCtx.lineTo(i * EXPLORE_CELL, SIZE);
            exploreCtx.stroke();
            exploreCtx.beginPath();
            exploreCtx.moveTo(0, i * EXPLORE_CELL);
            exploreCtx.lineTo(SIZE, i * EXPLORE_CELL);
            exploreCtx.stroke();
        }

        // Draw frontiers
        exploreCtx.fillStyle = "rgba(251, 146, 60, 0.7)";
        for(let f of exploreState.frontiers) {
            exploreCtx.fillRect(f.x * EXPLORE_CELL + 1, f.y * EXPLORE_CELL + 1, EXPLORE_CELL - 2, EXPLORE_CELL - 2);
        }

        // Draw target frontier
        if(exploreState.targetFrontier) {
            exploreCtx.strokeStyle = "#ef4444";
            exploreCtx.lineWidth = 2;
            exploreCtx.strokeRect(
                exploreState.targetFrontier.x * EXPLORE_CELL,
                exploreState.targetFrontier.y * EXPLORE_CELL,
                EXPLORE_CELL, EXPLORE_CELL
            );
        }

        // Draw sensor range indicator
        exploreCtx.beginPath();
        exploreCtx.arc(
            exploreState.robot.x * EXPLORE_CELL + EXPLORE_CELL/2,
            exploreState.robot.y * EXPLORE_CELL + EXPLORE_CELL/2,
            exploreState.sensorRange * EXPLORE_CELL,
            0, Math.PI * 2
        );
        exploreCtx.strokeStyle = exploreState.sensor === 'LASER' ? "rgba(59, 130, 246, 0.3)" : "rgba(16, 185, 129, 0.3)";
        exploreCtx.lineWidth = 2;
        exploreCtx.stroke();

        // Draw robot
        let rx = exploreState.robot.x * EXPLORE_CELL + EXPLORE_CELL/2;
        let ry = exploreState.robot.y * EXPLORE_CELL + EXPLORE_CELL/2;
        exploreCtx.beginPath();
        exploreCtx.arc(rx, ry, EXPLORE_CELL * 0.8, 0, Math.PI * 2);
        exploreCtx.fillStyle = "#3b82f6";
        exploreCtx.fill();
        exploreCtx.strokeStyle = "#1e40af";
        exploreCtx.lineWidth = 2;
        exploreCtx.stroke();

        // Robot direction indicator
        exploreCtx.beginPath();
        exploreCtx.moveTo(rx, ry);
        exploreCtx.lineTo(rx + EXPLORE_CELL * 0.6, ry);
        exploreCtx.strokeStyle = "white";
        exploreCtx.lineWidth = 2;
        exploreCtx.stroke();
    }

    // Explore canvas interactions
    exploreCanvas.addEventListener('mousedown', e => {
        if(currentView !== VIEWS.EXPLORE) return;
        const rect = exploreCanvas.getBoundingClientRect();
        const gx = Math.floor((e.clientX - rect.left) / (rect.width / EXPLORE_DIM));
        const gy = Math.floor((e.clientY - rect.top) / (rect.height / EXPLORE_DIM));

        // Click to move robot (only to free space)
        if(gx > 0 && gx < EXPLORE_DIM-1 && gy > 0 && gy < EXPLORE_DIM-1) {
            if(!isObstacle(gx, gy)) {
                exploreState.robot.x = gx;
                exploreState.robot.y = gy;
                drawExploreScene();
            }
        }
    });
    exploreCanvas.addEventListener('contextmenu', e => e.preventDefault());


    // Init
    resetGrid(); // Ensure grid is built
    resetExplore(); // Init exploration
    switchMainView('SAMPLING');

</script>
</body>
</html>